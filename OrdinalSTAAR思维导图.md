---
mindmap-plugin: basic
---

## NullModel

W_mat <- Diagonal(x = 1 / var_y)
X_t_W <- crossprod(X_mat, W_mat)
XWX_mat <- X_t_W %*% X_mat
XWX_inv <- solve(XWX_mat)
WX_mat <- t(X_t_W)

这五行代码的**唯一目的**是：**预先计算所有与基因型无关的、但计算起来又很慢的部分，为后续成千上万次快速的基因关联检验（分数检验）做好准备。**

### 1. 核心背景：分数检验 (Score Test)

后续的基因关联检验（如 `plof_ordinal`）使用的是分数检验。它的基本思想是：在零假设（基因对表型无影响）成立的模型下，检验遗传得分 `G` 是否与模型的残差 `residuals` 相关。

检验统计量 `T` 的形式为：`T = U² / Var(U)`

*   `U = G' * residuals` (得分统计量)
*   `Var(U)` (得分统计量的方差)

计算 `U` 非常快，就是向量的内积。但计算 `Var(U)` 要复杂得多，因为它必须**在校正了协变量 `X` 的影响之后**，计算 `U` 的方差。

### 2. `Var(U)` 的完整公式

在校正了协变量后，`U` 的方差公式为：

`Var(U) = G'WG - (G'WX) * (X'WX)⁻¹ * (X'WG)`

*   `G` 是基因型得分向量。
*   `W` 是权重矩阵 (即 `W_mat`)。
*   `X` 是协变量矩阵 (即 `X_mat`)。

这个公式分为两个部分：
1.  `G'WG`: 基因型得分的 **原始（未校正）方差**。
2.  `(G'WX) * (X'WX)⁻¹ * (X'WG)`: 由协变量 `X` 解释掉的那部分方差。我们从原始方差中**减去**这部分，得到校正后的方差。

当然，我们来详细梳理一下这些核心变量的维度。理解维度是掌握矩阵运算的关键。

为了具体说明，我们先设定一些符号：

*   `n`: 样本量 (即 `nrow(X_mat)`)
*   `p`: 协变量的数量 (包括截距项，即 `ncol(X_mat)`)

---

### 变量维度详解

#### 1. `W_mat`
```R
W_mat <- Diagonal(x = 1 / var_y)
```
*   **计算内容**: 创建一个对角矩阵。
*   **输入 `1 / var_y` 的维度**: 这是一个长度为 `n` 的向量，因为每个样本都有一个 `var_y` 值。
*   **输出 `W_mat` 的维度**: **`n x n`**
*   **结构**: 这是一个非常特殊的矩阵。除了主对角线上的 `n` 个元素（值为 `1/var_y`）之外，其他所有 `n² - n` 个元素都为零。在 `Matrix` 包中，它被高效地存储，并不会占用 `n x n` 的完整内存。

---

#### 2. `X_t_W`
```R
X_t_W <- crossprod(X_mat, W_mat)
```
*   **计算内容**: `X_mat` 的转置乘以 `W_mat`，即 `X'W`。
*   **输入 `X_mat` 的维度**: `n x p`
*   **输入 `W_mat` 的维度**: `n x n`
*   **运算过程**: `(X') * W`  ->  `(p x n) * (n x n)`
*   **输出 `X_t_W` 的维度**: **`p x n`**

---

#### 3. `XWX_mat`
```R
XWX_mat <- X_t_W %*% X_mat
```
*   **计算内容**: `X_t_W` 乘以 `X_mat`，即 `(X'W) * X`。
*   **输入 `X_t_W` 的维度**: `p x n`
*   **输入 `X_mat` 的维度**: `n x p`
*   **运算过程**: `(p x n) * (n x p)`
*   **输出 `XWX_mat` 的维度**: **`p x p`**
*   **解释**: 这是一个相对较小的方阵。它的维度只与协变量的数量有关，而与样本量 `n` 无关。这使得后续的求逆操作在 `p` 不大的情况下非常快。

---

#### 4. `XWX_inv`
```R
XWX_inv <- solve(XWX_mat)
```
*   **计算内容**: 对 `XWX_mat` 矩阵求逆，即 `(X'WX)⁻¹`。
*   **输入 `XWX_mat` 的维度**: `p x p`
*   **运算过程**: `solve(p x p matrix)`
*   **输出 `XWX_inv` 的维度**: **`p x p`**
*   **解释**: 这是信息矩阵的逆，也是分数检验方差计算中最核心的部分。

---

#### 5. `WX_mat`
```R
WX_mat <- t(X_t_W)
```
*   **计算内容**: 对 `X_t_W` (即 `X'W`) 进行转置。
*   **输入 `X_t_W` 的维度**: `p x n`
*   **运算过程**: `t(p x n matrix)`
*   **输出 `WX_mat` 的维度**: **`n x p`**
*   **解释**: 正如我们之前讨论的，`t(X'W)` 的结果是 `WX`。它的维度与 `X_mat` 相同。



## Ordinal_GeneCentricCoding

- ## Ordinal_plof

它的主要作用是：**针对单个指定基因，执行一套完整的、专门针对“预测的功能丧失性”(predicted Loss-of-Function, pLoF) 变异的关联性分析，并返回格式化的统计结果。**

#### 第1步：准备工作和全局筛选
*   **接收指令**: 函数接收用户输入的参数，如基因名 (`gene_name`)、基因组文件 (`genofile`)、以及最重要的 **预计算好的零模型** (`obj_nullmodel`)。
*   **确定分析样本**: 从 `obj_nullmodel` 中获取在模型拟合中实际使用的样本ID (`phenotype.id`)，确保后续分析的对象完全一致。
*   **初步筛选变异**: 它首先对整个基因组文件进行一次粗略扫描，根据QC标签 (`QC_label`) 和变异类型 (`variant_type`)，筛选出所有“合格”的变异。

#### 第2步：精确定位和功能注释筛选（核心步骤）
*   **定位基因**: 根据输入的 `gene_name`，从基因信息表 `genes` 中查找到该基因在染色体上的精确起止位置。
*   **筛选基因内变异**: 将第1步中合格的变异与基因位置进行匹配，筛选出所有落在这个基因区域内的变异。
*   **定义和筛选 pLoF 变异**: 这是函数名为 `plof` 的关键所在。它会读取变异的功能注释信息（如 `GENCODE.EXONIC.Category`），然后**只保留那些被标记为 "stopgain", "stoploss", "splicing" 等明确导致功能丧失的变异**。经过这一步，分析的焦点被精确地缩小到了pLoF变异上。

#### 第3步：提取基因型并进行质控
*   **提取基因型矩阵 (`Geno`)**: 针对最终筛选出的pLoF变异和分析样本，从基因组文件中提取它们的基因型数据（通常是dosage数据）。
*   **样本对齐**: 确保提取出的基因型矩阵的行序（样本顺序）与零模型中的样本顺序**严格一致**，这是保证统计计算正确性的关键。
*   **处理缺失值**: 对基因型矩阵中的缺失值进行插补（例如使用均值插补 `mean` 或次要等位基因频率插补 `minor`）。
*   **提取注释权重**: 如果用户选择使用注释权重 (`Use_annotation_weights=TRUE`)，它会提取这些pLoF变异的各种功能预测分数（如CADD, aPC等），用于在后续的检验中对不同变异赋予不同权重。

#### 第4步：执行核心统计检验（调用“引擎”）
*   **调度检验函数**: 这是整个流程的“引擎室”。它本身不直接进行复杂的统计计算，而是根据零模型的类型（如是否使用SPA，是否是多表型分析等）将准备好的数据（`Geno`, `obj_nullmodel`, 注释权重等）**传递给相应的底层STAAR检验函数**：
    *   `STAAR()`: 用于标准分析。
    *   `STAAR_Binary_SPA()`: 用于二分类表型且需要SPA校正的分析。
    *   `MultiSTAAR()`: 用于多表型分析。
    *   `AI_STAAR()`: 用于考虑人群祖源信息的分析。
*   **错误处理**: 使用 `try()` 来执行检验，这意味着即使某个基因的分析因为数学问题（如矩阵不可逆）而出错，整个流程也不会崩溃。

#### 第5步：整理并返回结果
*   **格式化输出**: 将底层检验函数返回的、结构比较复杂的列表（包含各种检验的p值、统计量等）整理成一个**整洁的、单行的矩阵或数据框** (`results`)。
*   **添加元信息**: 在结果行中加入基因名、染色体、分析类别 ("plof")、变异数量、累积等位基因数 (cMAC) 等信息。
*   **命名列**: 为结果矩阵的每一列赋予清晰的名称（如 "Gene name", "STAAR-O" 等）。
*   **清理环境**: 调用 `seqResetFilter(genofile)` 来重置对基因组文件的筛选器，这是一个非常重要的好习惯，确保此函数不会影响到后续对其他基因的分析。

---

### 总结

`plof` 函数是一个高度封装的自动化流程，它扮演了**“数据准备者”**和**“任务调度者”**的角色。它接收一个简单的指令（分析某个基因的pLoF变异），然后自动完成所有繁琐的中间步骤：**数据筛选、功能定义、质控、调用正确的统计引擎、最后打包成一个易于解读的结果**。









   - ## OrdinalSTAAR
   - ## ACAT
      ## Burden
      ## SKAT
      ## OrdinalSTAAR_O