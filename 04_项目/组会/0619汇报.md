#### 背景
##### 1. STAAR.R
###### 稀有变异分析面临两大挑战：

1. **信号微弱**：单个稀有变异的效应很小，需要把一个基因/区域内的多个稀有变异放在一起分析（即所谓的 "variant-set" test 或 "gene-based" test）才能有足够的统计功效。
    
2. **遗传异质性**：一个基因内的致病变异可能作用方向不同（有的有害，有的保护），效应大小也不同。有些变异可能没有功能，是中性的。

###### STAAR通过以下方式解决这些问题：

1. **综合多种检验模型**：它不假定所有变异都以同一种方式影响表型。因此，它同时运行了：
    
    - **Burden Test**: 类似负担检验，假设区域内所有稀有变异都朝同一个方向影响表型（全是有害或全是保护）。
        
    - **SKAT (Sequence Kernel Association Test)**: 类似方差分量检验，允许变异有不同方向和大小的效应。
        
    - **ACAT-V**: 一种高效的P值合并方法，对单个变异的得分进行加权合并。
        
2. **整合多种权重策略**：
    
    - **基于频率的权重**: 它使用Beta分布函数 dbeta(MAF, a, b) 作为权重，给频率更低的变异更高的权重。函数中使用了 dbeta(MAF, 1, 25)（极大地加权极稀有变异）和 dbeta(MAF, 1, 1)（即均匀分布，所有变异权重相同）两种策略。
        
    - **基于功能注释的权重**: 这是STAAR的精髓。它允许用户提供变异的功能预测得分（如CADD, MPC, LINSIGHT等），并将其转化为权重。代码中的 annotation_phred 参数就是用来做这个的。功能得分越高的变异，被认为越有可能是致病的，因此在检验中被赋予更高的权重。
        
3. **最终的综合决策 (Omnibus Test)**：STAAR不让你去猜哪种检验模型或哪种权重最合适。它把所有可能性都跑一遍，然后用**柯西组合检验 (Cauchy Combination Test, CCT)** 把所有得到的P值（来自SKAT/Burden/ACAT-V，以及结合了不同MAFs和功能注释权重的P值）合并成一个最终的P值，即 results_STAAR_O。这种做法非常稳健，无论真实的致病模式是怎样的，它都有很高的机会能检测到信号。

###### 当调用 STAAR 函数时，它内部执行了以下步骤：

1. **输入检查与数据准备**:
    
    - 检查 genotype (基因型矩阵)，obj_nullmodel (空模型) 等输入是否合规。
        
    - 使用 matrix_flip 计算每个变异的次要等位基因频率 (Minor Allele Frequency, MAF)。
        
    - 根据 rare_maf_cutoff (默认为0.01) 筛选出稀有变异。样本量太少或太多的基因集会被跳过。
        
2. **构建权重矩阵**:
    
    - **MAF权重**: 计算两个基础权重 w_1 (Beta(1,25)) 和 w_2 (Beta(1,1))。
        
    - **功能注释权重**: 如果提供了 annotation_phred，它会先把PHRED-scale的得分转换成一个0到1之间的"秩次"得分 (annotation_rank)。这个得分越高，代表该变异的功能性越强。
        
    - **组合权重**: 将MAF权重和功能注释权重相乘，生成一系列复杂的权重。例如，对于SKAT检验，它会生成：
        
        - 仅基于MAF的权重: w_1, w_2
            
        - 结合了功能注释的权重: w_1 * sqrt(annotation_rank), w_2 * sqrt(annotation_rank) (对于SKAT，权重是开根号的)。
            
    - 最终，它为 Burden、SKAT、ACAT-V 这三种检验方法，每种都准备了一套完整的权重（包括仅MAF的和结合了功能注释的）。
        
3. **执行关联检验**:
    
    - 该函数会判断空模型是针对无关样本 (glm) 还是相关样本/家系 (glmmkin)。
        
    - 它会调用底层的计算函数（如 STAAR_O_SMMAT 或 STAAR_O），传入基因型数据、空模型残差以及上一步生成的所有权重矩阵。
        
    - 对**每一种权重组合**，它都会计算出一个对应的 Burden P值, SKAT P值, 和 ACAT-V P值。例如，如果有3个功能注释，那么它会为SKAT(1,25)计算4个P值：1个基于MAF，3个基于MAF+每个注释。
        
4. **P值合并 (使用CCT)**:
    
    - **第一层合并 (STAAR-S, STAAR-B, STAAR-A)**：
        
        - 将所有 SKAT(1,25) 相关的P值（MAF权重的+所有功能注释权重的）合并成一个 STAAR-S(1,25) P值。
            
        - 对 SKAT(1,1), Burden(1,25), Burden(1,1), ACAT-V(1,25), ACAT-V(1,1) 做同样的操作。
            
    - **第二层合并 (STAAR-O)**：
        
        - 将**所有**在步骤3中计算出的原始P值（总共有 6 * (1 + num_annotations) 个）全部用CCT合并，得到最终的 omnibus P值 results_STAAR_O。这是最重要的结果。
            
    - **ACAT-O**：这是一个对比性的结果，它只合并了6个基于MAF权重的检验P值，没有利用功能注释信息。通过比较 STAAR-O 和 ACAT-O，可以评估功能注释是否提升了检验效力。
        
##### 2. fit_null_glmmkin.R（封装）

它的主要目的是在进行实际的基因关联检验之前，预先对表型数据进行校正，扣除掉那些非遗传因素，特别是**样本间的亲缘关系**和**群体分层**所带来的影响。

简单来说，这个函数通过以下两步来“清洗”表型数据：

1. 对已知的协变量（如年龄、性别、主成分等）进行校正。
    
2. 利用亲缘关系矩阵，对由样本间遗传相似性导致的表型相关性进行校正。

该函数最终的输出是一个“零模型”对象 (obj_nullmodel)，它包含了后续 STAAR 等函数进行高效、准确的基因关联检验所需的所有信息（例如，校正后的残差、方差组分等）。

fit_null_glmmkin 函数本质上是 **GMMAT** 包中 glmmkin 函数的一个智能“包装器”。它最大的附加价值在于它为了提升计算效率，对亲缘关系矩阵进行了巧妙处理。

###### 其内部逻辑流程如下：

1. **输入:** 用户提供：
    
    - fixed: 固定效应的公式 (例如, phenotype ~ age + sex)。
        
    - data: 包含表型和协变量的数据框。
        
    - kins: **亲缘关系矩阵**。这是一个 N x N 的矩阵（N为样本数），其中元素 (i, j) 代表个体 i 和 j 之间的遗传相关性系数。
        
    - id: 样本ID列。
        
2. **亲缘关系矩阵处理 (核心逻辑):** 这是该包装器函数的智能之处。
    
    - **情况一：kins 本身就是一个稀疏矩阵 (sparse matrix)。** 函数会识别到这一点，打印提示信息，然后直接调用 glmmkin。这是计算效率最高的情况。同时，它会在输出对象中设定一个标志 obj_nullmodel$sparse_kins <- TRUE。
        
    - **情况二：kins 是一个稠密矩阵 (dense matrix)，且用户设置 use_sparse = TRUE。** 这是非常常见且有用的情况。
        
        - **问题:** 使用稠密亲缘关系矩阵的混合模型计算量巨大（计算复杂度为 O(N³)），对于大规模数据集（例如，N > 20,000）是不可行的。
            
        - **解决办法:** 函数会尝试将这个稠密矩阵转换为一个稀疏的、块对角化的矩阵。它通过将所有小于 kins_cutoff 阈值（默认为0.022，约等于二代或三代亲属的亲缘度）的亲缘关系值设为0来实现。这相当于将样本聚类成一个个内部相关的“家族模块”，并假设模块之间无亲缘关系。
            
        - 然后，它用这个新的、计算上更容易处理的稀疏矩阵去调用 glmmkin，并设定标志 obj_nullmodel$sparse_kins <- TRUE。
            
    - **情况三：kins 是一个稠密矩阵，且用户设置 use_sparse = FALSE (或未设置)。** 函数会直接使用完整的稠密矩阵进行计算。这种方法最精确，但速度慢，只适用于较小的数据集。它会设定标志 obj_nullmodel$sparse_kins <- FALSE。
        
3. **模型拟合:** 函数将所有参数传递给强大的 glmmkin 引擎，后者使用高效的优化算法（如 "AI" 算法）来拟合广义线性混合模型。
    
4. **增强输出:** 它获取 glmmkin 的返回结果，并在输出对象中添加两个至关重要的自定义标志：
    
    - obj_nullmodel$relatedness <- TRUE: 这个标志明确地告诉下游函数，该模型是为亲缘样本拟合的。
        
    - obj_nullmodel$sparse_kins: 这个标志（TRUE 或 FALSE）告诉下游函数（如 STAAR）在计算关联检验的统计量时应该使用哪种算法，因为针对稀疏和稠密矩阵的计算方法是不同的。
###### 函数返回的对象包含了后续关联检验所需的一切：

1. 固定效应的估计系数
	- 虽然STAAR不直接使用这些系数，但它们是拟合零模型、计算残差的基础。
    
2. 估计的方差组分
    - 例如，如果输出的方差组分有两个：一个与 kins 关联的 τ_g = 0.4，一个残差方差 τ_e = 0.6。
    
    - 这表示，表型总方差的40% (0.4 / (0.4 + 0.6)) 可以由样本间的遗传相似性来解释。这通常被称为**窄义遗传力 (narrow-sense heritability, h²)** 的一个估计。
    
    - 剩下的60%是不能被亲缘关系解释的变异。
    
    - **方差组分的估计值 τ 是构建总协方差矩阵** Σ = τ_g * Kins + τ_e * I 的关键。这个 Σ 矩阵是后续所有计算（包括残差和投影矩阵）的核心。
    
3. **标准化残差 (scaled.residuals)**
	- 是对普通残差进行“缩放”处理后的结果。简单来说，它考虑了样本间的相关性。计算公式大致是 Σ⁻¹ᐟ² * (y - ŷ)。经过这个变换后，标准化残差近似服从一个均值为0、方差为1且相互独立的标准正态分布。
	
	- 它代表了在剔除了所有已知协变量（年龄、性别等）和亲缘关系的影响后，每个个体“剩余”的表型信号。如果一个基因区域内的稀有变异真的与表型有关，那么它们的效应就应该体现在这些标准化残差中。
	
	- STAAR关联分析的本质，就是检验基因型矩阵 G 是否与这些 scaled.residuals 相关。
    
4. **投影矩阵 (P 或 Sigma_i)**: 用于正确计算稀有变异检验统计量和P值的数学工具。
    - **是什么？**
	    - **P**是一个投影矩阵，P = Σ⁻¹ - Σ⁻¹X(X'Σ⁻¹X)⁻¹X'Σ⁻¹。
		    - 它有两个关键性质：
			    - (1) 将任何向量投影到与固定效应 X 正交的空间；
			    - (2) 在投影的同时，考虑了由 Σ 定义的相关性。
	    - **Sigma_i (Inverse of Sigma)**: 就是总协方差矩阵 Σ 的逆矩阵 Σ⁻¹。
        
	- **什么意思？**  
	    它们是计算关联检验统计量（Score Test statistic）的“引擎”。
	    Score检验的统计量通常具有 S'V⁻¹S 的形式，其中 S 是得分向量，V 是得分的方差。
	    这个 P 或 Sigma_i 就是计算 V⁻¹ 的核心部件。
    
	- **在STAAR中的作用？**  
	    **这是计算P值的关键**。当STAAR检验基因型 G 和标准化残差 scaled.residuals 的关系时，它需要正确计算检验统计量的方差，以判断观察到的关联有多显著。
	    - 如果fit_null_glmmkin的输出包含 P（通常用于稠密矩阵的情况），STAAR会用 G'PG 来计算方差。
	    - 如果输出包含 Sigma_i（通常用于稀疏矩阵的情况），STAAR会用 G'Σ⁻¹G 等形式的计算来得到方差。  
	    
5. relatedness 和 sparse_kins 两个标志，用于指导 STAAR 函数的内部逻辑。
	 - relatedness = TRUE: 明确告诉下游函数，这个零模型是为亲缘样本构建的。
	    
	- sparse_kins = TRUE/FALSE: 告诉下游函数，在构建模型时使用的亲缘关系矩阵是稀疏的还是稠密的。

###### 为什么不需要对fit_null_glmmkin 所拟合的GLMM的协变量标准化？
**核心原因：模型系数的尺度不变性（Scale Invariance）**

在线性模型（包括GLM和GLMM）中，每个协变量都有一个对应的回归系数（beta, β）。这个系数的估计值会自动适应其对应协变量的尺度（单位）。

###### 让我们用一个简单的例子来说明：  
假设我们有一个模型：身高(cm) = β₀ + β₁ * 年龄(岁)

- 这里的 β₁ 表示年龄每增加一岁，身高预期增加多少厘米。
    

现在，如果我们将年龄的单位从“岁”改成“月” (年龄(月) = 12 * 年龄(岁))，模型就变成了：  
身高(cm) = β'₀ + β'₁ * 年龄(月)

- 模型拟合后，你会发现新的系数 β'₁ 恰好是原来系数的 1/12，即 β'₁ = β₁ / 12。
    
- 虽然系数的数值变了，但它所代表的实际意义是完全一样的：年龄增加一年（12个月）对身高的影响是 12 * β'₁，这正好等于 β₁。
    

###### 关键结论：

- **模型拟合优度不变**：模型的似然值（Likelihood）、R² 等评估指标完全相同。
    
- **统计显著性不变**：协变量的P值是完全相同的。模型能同样有效地判断这个协变量是否与表型显著相关。
    
- **预测结果不变**：对于同一个体，用两个模型做出的预测结果是完全一样的。
    

fit_null_glmmkin 的主要目标是**校正协变量和亲缘关系的影响，得到准确的残差和方差估计**，以便用于后续的基因关联检验。由于上述的尺度不变性，无论你是否对协变量进行标准化，最终得到的用于下游分析的关键信息（如残差的分布、方差组分）在统计学意义上是等价的。

##### 3. glmmkin.R（二分类或连续型）

###### glmmkin 函数：用户接口与预处理层
###### glmmkin.fit 函数：核心计算引擎

**核心思想：PQL/MQL 迭代算法**

GLMM 的拟合通常没有封闭解，需要迭代计算。glmmkin 实现的是一种非常流行的算法，通常称为 **惩罚性拟似然（Penalized Quasi-Likelihood, PQL）** 或 **边际拟似然（Marginal Quasi-Likelihood, MQL）**。

其迭代步骤如下：

**For** i in 1 to maxiter:

1. **给定当前的方差组分估计 τ 和固定效应估计 α**:
    
    - 计算线性预测值 η = Xα。
        
    - 计算拟合值 μ = g⁻¹(η) (g⁻¹是连接函数的逆)。
        
    - **构造一个“伪响应变量”（Working/Pseudo-Response Variable）Y**:  
        Y = η + (y - μ) / g'(η)，其中 y 是原始表型，g' 是连接函数的导数。这一步将非正态的GLMM问题，在局部近似为一个正态的线性混合模型（LMM）问题。
        
    - **构造权重矩阵 W**: W 的权重与family的方差函数和连接函数有关。
        
2. **给定伪响应变量 Y 和权重 W，更新方差组分 τ**:
    
    - 此时，问题变成了拟合一个LMM：Y ~ N(Xα, Σ)，其中 Σ = W⁻¹ + Σ_kins(τ)。
        
    - glmmkin.fit 会调用一个专门的优化器来最大化此时的（限制性）似然函数，从而得到新的 τ。这就是不同 method.optim 发挥作用的地方：
        
        - method.optim = "AI": 调用 glmmkin.ai，使用**平均信息（Average Information, AI）算法**。这是一种基于得分和信息矩阵的快速、稳定的牛顿类算法，特别适合处理（稀疏）矩阵和多方差组分。代码显示它能够处理最复杂的情况，如异方差、随机斜率等。
            
        - method.optim = "Brent": 调用 glmmkin.brent，使用 **Brent 方法**。这是一种高效的一维优化算法，因此只能用于只有一个方差组分（即只有一个kins矩阵）的情况。
            
        - method.optim = "Nelder-Mead": 调用 glmmkin.nm，使用 **Nelder-Mead 单纯形法**。这是一种不需要导数的多维优化算法，可以处理多个方差组分，但通常比AI算法慢。
            
3. **给定新的方差组分 τ，更新固定效应 α**:
    
    - 有了新的 Σ，固定效应 α 的解可以通过广义最小二乘法得到：α = (X'Σ⁻¹X)⁻¹ X'Σ⁻¹Y。这一步在 glmmkin.ai 等底层函数内部完成。
        
4. **检查收敛**:
    
    - 比较新的 α 和 τ 与旧值 α₀ 和 τ₀。如果变化小于阈值 tol，则宣布收敛并退出循环。
###### 底层实现 (glmmkin.ai, glmmkin.brent 等)

这些是执行具体数学运算的函数，它们混合使用了 R 代码和对 C++ 代码的调用 ，以达到最佳性能。

- **glmmkin.ai (Average Information):** 这是最复杂也是功能最强的部分。它直接计算得分向量（似然函数的一阶导数）和平均信息矩阵（负的期望二阶导数）。然后通过解线性方程 AI * Δτ = score 来获得方差组分 τ 的更新步长 Δτ。这种方法收敛速度快，尤其是在使用稀疏矩阵时，可以通过专门的稀疏矩阵代数库（如Matrix包）进行高效计算。代码中的 R_fitglmm_ai 和 R_fitglmm_ai_dense 分别是为稀疏和稠密矩阵优化的纯R实现，而 C_fitglmm_ai 则是更快的C++版本。
    
- **glmmkin.brent (Brent's Method):** 当只有一个方差组分 τ 时，（限制性）似然函数是关于 τ 的一维函数。Brent方法结合了黄金分割搜索、二分法和抛物线插值，是一种非常稳健和快速的一维函数求极值方法。

#### 1. 为什么STAAR在多分类表型实现拟合零模型和关联分析挑战很大？

1. glmmkin 和 GLMM 框架的限制

fit_null_glmmkin 函数的核心是广义线性混合模型（GLMM）。标准的GLMM框架是为以下类型的响应变量设计的：

- **连续型 (Continuous)**: family = gaussian()
    
- **二分类 (Binary)**: family = binomial()
    
- **计数型 (Counts)**: family = poisson()
    
- **比例型 (Proportions)**: family = quasibinomial()
    
- **其他单参数指数族分布**: 如 Gamma, inverse.gaussian

**核心差异在于：**

- **GLM/GLMM**: 响应变量 y 是一个向量 (vector)。模型只有一个线性预测器 η。

- **多项式回归**: 响应变量 y 本质上是多维的。如果以一个类别为参照（reference level），模型需要同时估计 K-1 个线性预测器，每个预测器对应一个类别与参照类别的对数比值（log-odds）。

- 将这种多维结构嵌入到混合模型中，就构成了**多项式广义线性混合模型 (Multinomial GLMM)**。这是一个比标准GLMM复杂得多的模型。

2. fit_null_glmmkin 扩展到多分类的挑战（POLMM)

要修改 fit_null_glmmkin 来支持多分类表型，你需要：

1. **重写核心拟合算法 (glmmkin.fit 等)**:
    
    - **伪数据 (Pseudo-data) 的改变**: PQL/MQL算法的核心是构造一个“伪响应变量”。对于多项式模型，你不能只构造一个伪响应向量 Y，而是需要构造一个 N x (K-1) 的伪响应矩阵。
        
    - **权重矩阵的改变**: 权重矩阵 W 不再是一个对角阵，而是一个块对角阵（block-diagonal matrix），每个样本对应一个 (K-1) x (K-1) 的协方差矩阵块。
        
    - **方差组分结构**: 随机效应的结构也变得复杂。最简单的情况是，所有 K-1 个线性预测器共享同一个由亲缘关系定义的随机效应。但更复杂的模型可能允许不同类别之间随机效应的协方差。
        
    - **优化过程**: 似然函数的计算、得分向量和信息矩阵的推导都将变得非常复杂，需要专门的数学推导和编程实现。
        
2. **软件支持**:
    - 现有的 glmmkin 代码（包括底层的C++代码）是为单维响应变量设计的。你需要从底层重构它，以处理多维响应和块对角权重矩阵。
        
    - R中虽然有一些包可以拟合多项式GLMM（如 MCMCglmm, brms 等，通常基于贝叶斯方法），但很少有像 GMMAT 这样为大规模基因组学数据优化的高效频率派实现。
3. STAAR 扩展到多分类的挑战(MSKAT、M-Burden、M-O)

即使你成功地拟合了多项式GLMM零模型，将 STAAR 关联检验扩展过去同样困难：

1. **Score检验的重新推导**:
    
    - 标准的Score检验是为单个遗传效应参数 γ 设计的。在多分类背景下，一个变异对表型的影响可能也是多维的，即它对每个类别（相对于参照）都有一个效应，构成一个效应向量 γ = (γ₁, γ₂, ..., γ_{K-1})。
        
    - 因此，零假设 H₀: γ = 0 是一个多维假设。你需要推导一个**多自由度的Score检验**。这通常是一个卡方检验（Chi-squared test），其自由度与效应向量的维度有关。
        
2. **权重和检验类型的扩展**:
    
    - **Burden Test**: 可以相对直接地扩展。将每个类别下的Burden得分组合起来，形成一个 (K-1) 维的综合Burden得分向量，然后进行多自由度的检验。
        
    - **SKAT**: 扩展起来更复杂。你需要定义一个 (K-1) x (K-1) 的核函数来衡量基因型相似性如何影响多维表型相似性。最终的检验也是一个基于混合卡方分布的方差分量检验。
        
    - **ACAT-V**: 这个基于P值合并的方法可能更难直接应用，因为基础的单变量P值不再存在。你需要找到一种方法来合并多维检验的证据。
        
3. **综合检验 (Omnibus Test)**:
    
    - STAAR-O 的核心是合并大量P值。你需要重新设计这个流程，使其能够合并来自多自由度检验的证据，或者找到一种替代的综合检验策略。

#### 2. 有序多分类表型的现有方法
1. **模型结构介绍**
    logit(P(Y ≤ k)) = αₖ - (Xβ + Zμ)
    
    - P(Y ≤ k): 个体表型属于类别 k 或更低类别的累积概率。
        
    - αₖ: 每个类别 k 的截距（或阈值）。
        
    - Xβ: 固定效应部分，**这里的 β 仍然是一个向量**，代表协变量的效应。
        
    - Zμ: 随机效应部分，μ 通常假设服从一个均值为0，协方差矩阵为 τ * Kins 的正态分布，用来校正亲缘关系。
2. **用GRAB拟合（wenjian老师）✅
	- wenjian老师用的是ordinal 包中的 clmm() 函数 (Cumulative Link Mixed Models)
3. **用GENESIS拟合❓
	- 调用fitNullModel()：
		- null_model_ordinal <- fitNullModel( dat, outcome = "your_ordinal_phenotype_column_name", covars = c("age", "sex", "pc1", "pc2", ...), cov.mat = grm, family = "binomial",  outcome.type = "ordinal")
		
	- family = "binomial": 你可能会觉得奇怪，为什么有序表型要用 binomial？这是因为有序模型（如比例优势模型）在数学上可以被看作是一系列二项分布的扩展。在GENESIS的内部实现中，它利用了这个联系。**这是 GENESIS 的一个特定语法，需要记住。**
		
	- outcome.type = "ordinal": 这个参数明确地告诉 fitNullModel，虽然 family 是 binomial，但你实际上要拟合的是一个**累积链接混合模型（Cumulative Link Mixed Model）**，也就是我们之前讨论的比例优势混合模型（POGLMM）。
	
	- GENESIS会：
		1. **拟合一个POGLMM零模型**: 它会为你拟合一个比例优势混合模型，模型中包含了你指定的固定效应协变量以及由亲缘关系矩阵 grm 定义的随机效应。
	    
		2. **计算Score向量和方差**: 它会计算出后续关联检验所需的Score向量（可以理解为校正后的残差）以及其协方差矩阵的必要部分。
4. **比较GRAB包和GENESIS包
	- **GENESIS**:
	    
	    - **传统混合模型算法**: 在处理稠密GRM时，GENESIS 采用的是需要显式计算和存储N x N亲缘关系矩阵 K 的方法。然后通过矩阵分解（如Cholesky分解）来计算 K⁻¹ 或相关项。
	        
	    - **计算瓶颈**: 这种方法的计算复杂度和内存需求是 O(N²) 到 O(N³)，这使得它在样本量 N 超过几万时变得非常缓慢和耗费内存。
	        
	- **GRAB**:
	    
	    - **借鉴SAIGE的先进算法**: GRAB 的文档中提到了 SAIGE，并且其control参数（如 maxiterPCG, tolEps, LOCO）强烈暗示它采用了与SAIGE类似的**免GRM计算（GRM-free）** 策略。
	        
	    - **PCG算法**: 它很可能使用**预条件共轭梯度法（Preconditioned Conjugate Gradient, PCG）** 来求解大规模线性方程组，而避免了直接计算和存储整个N x N的GRM矩阵。相反，它只需要计算形如 K*v（GRM矩阵乘以一个向量）的乘积，这个乘积可以高效地从原始基因型数据（如PLINK文件）中直接计算，其复杂度大约是 O(MN)（M是SNP数量，N是样本量）。
	        
	    - **性能优势**: 这种方法极大地降低了内存消耗和计算时间，使得分析数十万甚至上百万样本成为可能。这是GRAB相比于采用传统方法的GENESIS在处理超大规模数据时的一个**决定性优势**。
	        
	    - **LOCO (Leave-One-Chromosome-Out)**: 这个参数也是SAIGE和BOLT-LMM的标志性特征，用于在拟合零模型时避免“近端污染”（proximal contamination），从而减少假阳性。GRAB内置了这一功能，而GENESIS需要用户手动实现。

	**当GRM是稀疏的时，两个包都会采用为稀疏矩阵优化的算法，这使得它们的计算性能变得更加接近。**
	
	- **GENESIS**:
	    
	    - **算法**: GENESIS 可以很好地处理稀疏矩阵（通过Matrix包）。当拟合混合模型时，它会利用矩阵的稀疏性来执行高效的Cholesky分解（chol）或使用其他稀疏线性代数方法。
	        
		    - **性能**: 对于稀疏GRM，计算复杂度和内存需求不再是O(N²), 而是与矩阵中非零元素的数量相关。这使得GENESIS在处理稀疏GRM时也能够扩展到相当大的样本量（例如，数十万），只要GRM足够稀疏。
	        
	- **GRAB**:
	    
	    - **算法**: GRAB的文档明确支持SparseGRMFile。它内部很可能也使用了高效的稀疏矩阵库（如Eigen C++ library）来处理计算。它的核心拟合算法（可能是基于PQL/MQL的迭代过程）会充分利用稀疏性。
	        
	    - **性能**: GRAB的底层C++实现通常会比GENESIS中基于R和Matrix包的实现有微弱的速度优势，但这不再是像稠密GRM情况下的数量级差异。两者在性能上处于**同一梯队**。
	        
	
	**结论**: 在稀疏GRM的情况下，**两者的计算性能是可比的，不存在根本性的优劣之分。** GRAB可能略快一些，但差异不大。
5. **关联检验介绍
	1. **零模型：一切差异的起点**
	
		- **标准 Burden/SKAT (用于二分类/定量表型)**:
		    
		    - **零模型**: 广义线性混合模型（GLMM）。
		        
		    - **目标**: 预测表型的期望值 E(y)（例如，患病概率或某个指标的平均值）。
		        
		    - **残差**: resid = y - E(y)。这是一个**一维向量**，每个样本对应一个残差值。经过“白化”处理后，得到 scaled.residuals 或 Ytilde。
		        
		- **Ord-Burden/Ord-SKAT (用于有序表型)**:
		    
		    - **零模型**: 比例优势混合模型（POGLMM）或累积链接混合模型（CLMM）。
		        
		    - **目标**: 预测表型属于某个类别或更低类别的**累积概率** P(Y ≤ k)。
		        
		    - **“残差”**: 这里的“残差”在数学上更复杂。它不是一个简单的 y - ŷ。在Score检验的框架下，它是**似然函数对遗传效应参数的梯度（一阶导数）**。因为有序模型有 K-1 个累积概率，这个梯度实际上是一个**多维的实体**。虽然最终的Score统计量可以被简化，但其推导过程考虑了所有类别和它们之间的顺序。
	
	2. **Score检验统计量：形式相似，内容不同**
	
		Score检验的基本形式是 S'V⁻¹S，其中 S 是得分（Score），V 是得分在零假设下的方差。Burden和SKAT都是Score检验的特例。
		
		- **Burden**:
		    
		    1. 计算一个**一维**的Burden Score: G_burden = G %*% w (G是基因型矩阵，w是权重)。
		        
		    2. 计算G_burden与**一维**残差 Ytilde 的协方差（或相关性）。
		        
		    3. 检验统计量大致是：(G_burden' * Ytilde)²。这是一个**1个自由度的卡方检验**。
		        
		- **Ord-Burden**:
		    
		    1. 计算的Burden Score G_burden 仍然是**一维**的。
		        
		    2. 但是，它检验的是这个G_burden与POGLMM零模型推导出的、蕴含了类别顺序信息的“梯度”之间的关系。
		        
		    3. 尽管推导过程更复杂，但因为它检验的是**一个**综合遗传效应（Burden Score）的影响，最终的检验统计量也简化为一个**1个自由度的卡方检验**。
		        
		- **结论1**: Burden 和 Ord-Burden 在**最终形式上非常相似**（都是1自由度检验），但 Ord-Burden 的计算考虑了有序表型的累积概率结构，因此统计功效更高，结果也更有效。
		
		- **SKAT**:
		    1. 假设每个变异 j 有一个独立的、服从 N(0, τ) 分布的效应 β_j。
		        
		    2. 检验的零假设是 H₀: τ = 0。
		        
		    3. 检验统计量是二次型：Q = Ytilde' * (Gtilde %*% diag(w²) %*% t(Gtilde)) * Ytilde。
		        
		        - Ytilde 是一维的GLMM残差。
		            
		        - Gtilde 是校正后的一维基因型。
		            
		        - Q 是一个**标量（scalar）**。
		            
		    4. Q 的分布是**混合卡方分布**。
		        
		- **Ord-SKAT**:
		    
		    1. 它同样假设每个变异 j 有一个随机效应 β_j。
		        
		    2. 但是，这个效应 β_j 是作用在POGLMM的**线性预测器**上的。
		        
		    3. 检验的零假设同样是 H₀: τ = 0。
		        
		    4. 检验统计量也是一个二次型 Q，但它的计算涉及**POGLMM的复杂梯度和Hessian矩阵**。
		        
		        - 虽然形式上也可以写成类似 Q = S'S 的形式，但这里的Score向量 S 是从POGLMM的似然函数推导出来的，它内部已经编码了所有 K-1 个阈值的信息。
		            
		    5. Q 的分布同样是**混合卡方分布**。
		        
		- **结论2**: SKAT 和 Ord-SKAT 在**概念上是平行的**（都是方差分量检验），并且**最终都归结为对一个二次型统计量进行混合卡方检验**。然而，**计算这个二次型统计量的所有“零件”（Score向量、方差等）都是从各自完全不同的零模型（GLMM vs. POGLM）中推导出来的**。Ord-SKAT正确地利用了类别的顺序信息，因此是分析有序表型的正确方法。
6. **GRAB 进行稀有变异集合检验（wenjian老师）**
	
	GRAB 的文档显示，它同样将分析分为两步：
		Step 1 GRAB.NullModel
		Step 2 GRAB.Region
	
	- **工作流程：**
		
		1. **准备输入文件**:  
		    GRAB 的设计更偏向于命令行工具，它可能需要你准备一个文件来定义要检验的基因/区域和其中的变异。这通常是一个 **SetID文件**（或Grouping文件），格式通常是：
		    
		    ```
		    GENE_A   variant1
		    GENE_A   variant2
		    GENE_A   variant3
		    GENE_B   variant4
		    GENE_B   variant5
		    ...
		    ```
		    以及一个**稀有变异列表文件**。
		    
		2. **调用 GRAB.Region()**:  
		    将第一步拟合的零模型对象 (obj.POLMM)，以及基因型文件和区域定义文件等传入 GRAB.Region()。
		    
	
	- **GRAB 的特点和优势：**
	
		- **高性能**: 继承了 GRAB.NullModel 的高性能设计，GRAB.Region 的后端很可能也是用C++实现的，可以极快地处理大规模基因型数据（PLINK/BGEN）和大量的基因区域。
		    
		- **支持多种检验**: 从其框架来看，它很可能支持主流的 Burden, SKAT, 以及高效的P值合并方法如 ACAT-O。
		    
		- **可能支持STAAR策略**: GRAB的设计哲学（高性能、自动化、借鉴SAIGE）与STAAR非常相似。它很有可能内置了类似STAAR-O的策略，即自动进行多种权重（MAF+功能注释）下的多种检验，并用ACAT-O或类似方法合并成一个最终的综合P值。这会是它相比GENESIS的一个潜在优势。
		    
		- **文件驱动**: 它的工作方式更依赖于标准化的输入文件（SetID文件，注释文件），而不是R中的对象。这使得它更容易被整合到自动化的Snakemake或Nextflow流程中。
7. **GENESIS 进行稀有变异集合检验（参考了 林希虹团队）**
	
	GENESIS 提供了一个内置的、功能全面的函数 **assocTestAggregate()** 来执行这项任务。
	
	- **工作流程：**
	
		1. **准备基因型数据迭代器 (Iterator)**:  
		    GENESIS 与 SeqArray 包紧密集成，要求你首先创建一个迭代器，该迭代器可以高效地逐个基因/区域地从GDS文件中读取基因型数据。
		    
			```
			library(SeqArray)
			library(GenomicRanges)
			
			# 1. 打开GDS文件
			gdsfile <- seqOpen("my_genotypes.gds")
			
			# 2. 创建一个定义了基因区域的GRanges对象
			# (可以从UCSC, Ensembl等下载基因定义文件来创建)
			gene_regions <- GRanges(seqnames = "chr1",
									ranges = IRanges(start = c(1000, 5000), end = c(3000, 7000)),
									name = c("GENE_A", "GENE_B"))
			
			# 3. 创建迭代器
			iterator <- SeqVarRegionIterator(gdsfile, variantRanges = gene_regions)
			```
		    
		2. **调用 assocTestAggregate()**:  
		    将之前拟合的零模型对象 (null_model_ordinal) 和迭代器传入 assocTestAggregate()。
		    
		    ```
		    # 假设 null_model_ordinal 是用 fitNullModel 拟合好的零模型
		    
		    agg_results <- assocTestAggregate(
		        iterator,
		        null.model = null_model_ordinal,
		        AF.max = 0.01, # 定义稀有变异的MAF上限
		        weight.beta = c(1, 25), # MAF的Beta分布权重 (a=1, b=25) -> Burden
		        weight.user = "my_annotation_score", # 使用功能注释作为权重 (可选)
		        test = "Score.Aggregate", # 基础检验类型
		        burden.test = "Burden", # 指定进行Burden检验
		        skat.test = "SKAT", # 指定进行SKAT检验 (会进行Ord-SKAT)
		        verbose = TRUE
		    )
		    
		    # 查看结果
		    head(agg_results$results)
		    ```
	- **GENESIS 的特点和优势：**
		- **内置多种检验**: 直接支持 Burden, SKAT, SKAT-O, Fast-SKAT, SMMAT 等多种集合检验。当零模型是有序模型时，它会自动执行这些检验的有序版本 (Ord-Burden, Ord-SKAT等)。
		    
		- **灵活的权重**:
		    
		    - 可以通过 weight.beta 参数轻松指定基于MAF的Beta分布权重。
		        
		    - 可以通过 weight.user 参数指定一个存储在GDS文件中的功能注释分数（如CADD, MPC）作为权重。
		        
		- **与数据格式紧密集成**: 通过迭代器模式，可以高效处理大规模全基因组数据，而无需将整个基因型矩阵一次性读入内存。
		    
		- **一体化**: 从零模型到关联检验，所有操作都在GENESIS框架内完成，保证了数据和对象格式的兼容性。
8. **rvtest进行稀有变异集合检验（林希虹团队）**
9. **尝试与STAAR框架结合并总结优势
	- 整合GRAB和STAAR（性能功效）
	- 整合GENESIS和STAAR（灵活）
		- **实现方式**: 完全在R环境中，编写R脚本来循环调用GENESIS::assocTestAggregate，最后用ACAT包合并P值。
	- 整合rvtest和STAAR（高性能）
		- **实现方式**: 在Shell/Bash中编写脚本来循环调用rvtest命令行程序，然后在R中对输出的文本文件进行最后的汇总和合并。
	- 选择？
#### 3. 无序多分类表型的现有方法
#### 4. 接下来的工作方向

##### 1. 基于分解的策略（最坏打算）

这是最直接、最容易实现的方法，因为它利用了现有的二分类关联分析工具（如 STAAR, SKAT, GMMAT）。

###### 方法：

将一个多分类问题拆解成多个二分类问题。

- **一对多 (One-vs-Rest)**:
    
    - **场景**: 表型有K个类别（例如，疾病亚型A、B、C和健康对照D）。
        
    - **做法**: 进行 K-1 次分析。
        
        1. 亚型A vs. (B+C+D)
            
        2. 亚型B vs. (A+C+D)
            
        3. 亚型C vs. (A+B+D)
            
    - **问题**: 这种方法主要检验每个亚型与其“非自身”群体的差异，但混合的对照组可能会稀释信号。
        
- **一对一 (One-vs-One / Case-Case)**:
    
    - **场景**: 主要关注不同疾病亚型之间的遗传差异。
        
    - **做法**:
        
        1. 亚型A vs. 亚型B
            
        2. 亚型A vs. 亚型C
            
        3. 亚型B vs. 亚型C
            
    - **问题**: 这种方法能有效发现导致亚型异质性的遗传因素，但无法找到所有亚型共有的致病基因。
        
- **一对参照 (One-vs-Reference)**:
    
    - **场景**: 有一个明确的参照组，通常是健康对照。
        
    - **做法**: 这是最常用和最推荐的分解策略。
        
        1. 亚型A vs. 对照
            
        2. 亚型B vs. 对照
            
        3. 亚型C vs. 对照
            
    - **优点**: 每次分析的目标明确，易于解释。
        
    - **缺点**: 仍然没有充分利用所有数据的信息，可能会因为将亚型分开而损失统计功效（如果一个基因同时影响多个亚型）。
        

**共同挑战**:  
所有分解策略都面临**多重检验校正**的问题。如果你做了 M 次分析，你需要对最终的P值进行校正（如Bonferroni校正），这会降低发现显著信号的能力。
还有一个是计算成本的问题。

---

##### 2. 直接建模的多维检验方法(MSKAT、M-Burden、M-O)

这类方法试图在一个统一的模型中同时分析所有类别，从而避免分解带来的问题。它们通常是标准关联检验的多维扩展。

###### 方法：

基于**多项式逻辑回归 (Multinomial Logistic Regression)** 的框架。模型会同时估计 K-1 个效应（每个类别相对于参照类别）。

- **多项式Score检验 (Multinomial Score Test)**:
    
    - 这是单变异关联分析（Single-variant association）的标准扩展。
        
    - 对于每个SNP，检验的零假设是它对所有 K-1 个类别的效应都为零 (H₀: β₁=β₂=...=β_{K-1}=0)。
        
    - 检验统计量通常服从一个**自由度为 K-1 的卡方分布**。
        
- **M-Burden (Multinomial Burden Test)**:
    
    - 这是Burden test的扩展。
        
    - 首先，计算一个基因区域内所有稀有变异的加权和（Burden score）。
        
    - 然后，将这个Burden score作为协变量放入多项式逻辑回归模型中，进行一个 K-1 自由度的Score检验或似然比检验。
        
- **MSKAT (Multinomial Sequence Kernel Association Test)**:
    
    - 这是SKAT的直接扩展，由 Larson et al. (2019) 提出。
        
    - 它检验的是基因区域内的变异对多维表型（K-1个类别）的总体方差贡献是否为零。
        
    - 检验统计量不再是单个方差分量，而是一个**方差分量矩阵**。最终的P值通过复杂的数值方法（如特征值分解和混合卡方分布）计算得到。
        
    - **优点**: 功能强大，能捕捉复杂的遗传效应模式（例如，一个基因可能增加患亚型A的风险，但降低患亚型B的风险）。
        
- **M-O (Multinomial Omnibus Test)**:
    
    - 类似于SKAT-O或ACAT-O，这是一个综合 M-Burden 和 MSKAT 的综合检验。
        
    - 它旨在对不同的遗传效应模式（Burden-like vs. SKAT-like）都保持较高的统计功效。
        

**共同挑战**:  
这些方法的实现比较复杂，需要专门的软件。虽然理论上更优，但可能不如分解策略那样普及和易用。