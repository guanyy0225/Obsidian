好的，我们来深入剖析这段代码将有序多分类转化为连续型的**核心统计学原理**。

这个转化的过程非常精妙，它基于**潜在变量模型 (Latent Variable Model)** 的思想，并通过计算**截尾正态分布的期望 (Expectation of a Truncated Normal Distribution)** 来实现。

整个过程可以分解为以下三个概念步骤：

---

### 第 1 步：假设存在一个不可观测的连续变量 `Y*`

这是所有有序模型（Probit 和 Logit）的理论基石。我们假设：

1.  **存在一个潜在变量 `Y*`:** 在你观测到的有序类别（“从不喝酒”、“偶尔喝”……）背后，存在一个**不可观测的、连续的**“酒精摄入倾向”谱系。我们称之为 `Y*`。
2.  **`Y*` 服从正态分布:** 我们进一步假设，在整个人群中，这个 `Y*` 服从一个标准正态分布（均值为 0，方差为 1）。
3.  **观测类别是 `Y*` 被阈值切割的结果:** 我们能观测到的离散类别，仅仅是这个连续的 `Y*` 被一系列**阈值 (thresholds)** `α` 切割后，个体掉入的不同区间。

**可视化这个概念：**

```
<-- 非常低的饮酒倾向                             非常高的饮酒倾向 -->
...-Inf----(α₁)----(α₂)----(α₃)----(α₄)----(α₅)----+Inf...  (Y* 的连续谱)
    |       |       |       |       |       |
  "Never" | "Occ."| "Monthly"| "Weekly"| "Often" | "Daily"    (观测到的 Y 类别)
  (Cat 1) | (Cat 2) | (Cat 3) | (Cat 4) | (Cat 5) | (Cat 6)
```
*   如果一个人的 `Y*` 值小于 `α₁`，我们就观测到他/她是 “Never”。
*   如果一个人的 `Y*` 值在 `α₁` 和 `α₂` 之间，我们就观测到他/她是 “Special occasions only”。
*   依此类推。

---

### 第 2 步：估计阈值 `α`

**你的 `Step 4` (拟合仅截距项模型) 的唯一目的，就是从数据中估计出这些阈值 `α` 的最佳位置。**

```R
intercept_only_formula <- as.formula("alcohol_intake_frequency ~ 1")
clm_intercept_obj <- ordinal::clm(formula = intercept_only_formula, ...)
```
*   当你拟合一个只有截距项的模型时，`clm` 函数会忽略所有协变量，只根据你数据中**每个类别的样本比例**来确定阈值 `α` 的位置。
*   例如，如果有 10% 的人是 “Never”，`clm` 就会将第一个阈值 `α₁` 设置在标准正态分布的 **10% 分位数**上 (`qnorm(0.1)`)。如果有 25% 的人是 “Never” 或 “Occasions only”，它就会将第二个阈值 `α₂` 设置在 **25% 分位数**上 (`qnorm(0.25)`)。
*   `clm_intercept_obj$alpha` 中存储的就是这些估计出的阈值。

---

### 第 3 步：为每个个体“反推”其 `Y*` 的期望值 (核心计算)

**这是你的 `Step 5` 的核心任务，也是转化的魔法所在。**

现在，对于**每一个**样本，我们都知道他/她最终落在了哪个类别区间。例如，一个样本被观测为 “Monthly” (类别 3)。

*   **我们知道什么？** 我们知道他/她的 `Y*` 值，一定位于 `α₂` 和 `α₃` 之间。
*   **我们不知道什么？** 我们不知道他/她在 `(α₂, α₃)` 这个区间内的**确切位置**。他/她是更接近 `α₂` 还是更接近 `α₃`？

**为了得到一个单一的、连续的数值来代表这个样本，我们能做的最好的事情，就是计算他/她 `Y*` 值的数学期望。**

这在数学上被称为计算**截尾正态分布的期望 (Expectation of a Truncated Normal Distribution)**。
*   我们有一个标准正态分布。
*   我们知道这个分布被截断在了 `(α₂, α₃)` 这个区间内。
*   我们要计算这个**被截断后的新分布的均值**。

这个计算的**解析解 (analytical solution)** 正是你的代码所实现的：
`E[X | a < X < b] = (ϕ(a) - ϕ(b)) / (Φ(b) - Φ(a))`

让我们把它与你的代码进行匹配：
*   `a` 和 `b` 就是你的 `lower_b` 和 `upper_b`（即 `α_{j-1}` 和 `α_j`）。
*   `ϕ` 是标准正态分布的**概率密度函数 (PDF)**，在 R 中是 `dnorm()`。
*   `Φ` 是标准正态分布的**累积分布函数 (CDF)**，在 R 中是 `pnorm()`。
*   `Φ(b) - Φ(a)` 就是你的 `prob_interval`。

所以，这行代码：
```R
latent_variable <- (dnorm(lower_b) - dnorm(upper_b)) / prob_interval
```
**其原理是：为每一个样本，根据他/她所属的有序类别，计算出其潜在正态变量 `Y*` 在该类别区间内的数学期望值。**

**最终产物 `latent_variable`**：
*   所有属于类别 1 (“Never”) 的人，会得到一个相同的、代表该区间期望值的负数。
*   所有属于类别 2 (“Occasions only”) 的人，会得到另一个相同的、比类别 1 稍大的负数。
*   ...
*   所有属于类别 6 (“Daily”) 的人，会得到一个相同的、代表该区间期望值的正数。

这个 `latent_variable` 现在是一个**阶梯状的连续变量**，它已经成功地将离散的类别，映射到了一个连续的、有意义的潜在尺度上。最后的 `INT` 步骤（`Step 6`）则是为了将这个阶梯状的分布“平滑”成一个完美的正态分布，以便 `REGENIE` 更好地处理。

**总结：**
转化的原理是**基于潜在变量理论，通过拟合一个简单的有序模型来估计人群中不同类别之间的阈值，然后为每个样本，计算其潜在变量在已知类别区间内的条件数学期望，从而将离散的有序类别“解码”回其潜在的连续尺度上。**



## nullmodel的区别

好的，这是一个非常棒的总结性问题。现在我们已经深入了解了两个框架的内部实现，我们可以精确地、并排地比较它们在**核心矩阵运算步骤**中的根本区别。

**总的来说，`SurvSTAAR` 和 `OrdinalSTAAR` 在矩阵运算上的核心区别，源于它们所基于的统计模型的根本不同：`SurvSTAAR` 基于 Cox 模型的偏似然理论，而 `OrdinalSTAAR` 基于广义线性模型 (GLM) 的标准似然理论。**

这导致了它们在计算**分数检验的协方差**时，使用了**不同的数学公式**和**不同的矩阵组件**。

---

### 矩阵运算步骤的并排对比

| 步骤/组件 | `SurvSTAAR` (基于 Cox 模型) | `OrdinalSTAAR` (基于 有序 Probit 模型 / GLM) | 区别分析 |
| :--- | :--- | :--- | :--- |
| **1. 核心残差 (`res_null`)** | **鞅残差 (Martingale Residuals)**<br>`res = status - expected_cumulative_hazard` | **潜在变量残差 (Latent Variable Residuals)**<br>`res = E[ε | Y, X]` | **根本不同。** 两者的理论基础、计算方法和统计学解释完全不同。这是所有后续差异的根源。 |
| **2. 权重矩阵 `W_mat`** | `W_mat = Diagonal(x = mu_null)`<br>其中 `mu_null = status - res_null` | `W_mat = Diagonal(x = 1/var_y)`<br>其中 `var_y` 是潜在变量残差的条件方差 | **根本不同。** `SurvSTAAR` 的 `W` 矩阵与期望的累积风险有关。`OrdinalSTAAR` 的 `W` 矩阵是 GLM 框架下的标准“工作权重”，代表了每个观测信息量的倒数。 |
| **3. P 矩阵 (`t_P_mat`)** | **存在且至关重要。**<br>通过一个复杂的循环，根据每个事件时间点的风险集计算得出。 | **完全不存在。** | **这是最关键的区别。** P 矩阵是专门为了处理 Cox 模型中由“风险集”引入的复杂依赖结构而生的。GLM 框架没有这个概念，因此 `OrdinalSTAAR` 不需要它。 |
| **4. 设计矩阵 `X_mat`** | `X_mat = as.matrix(use_data[, covCol])`<br>**不包含**截距项。 | `X_mat = model.matrix(clm_obj)`<br>**包含**截距项。 | **定义不同。** `SurvSTAAR` 的推导将截距视为基准风险的一部分，而 `OrdinalSTAAR` (GLM) 将截距作为设计矩阵的一部分（尽管 `clm` 将其视为阈值）。 |
| **5. 核心方差组件的计算** | `XVX_inv = solve(XWX_mat - XPPX_mat)`<br>其中 `XWX_mat = t(X)WX`<br>`XPPX_mat = t(PX)PX` | `XWX_inv = solve(XWX_mat)`<br>其中 `XWX_mat = t(X)WX` | **公式不同。** `SurvSTAAR` 的方差公式中，必须**减去**由 P 矩阵捕获的、风险集结构引入的方差 (`XPPX_mat`)。`OrdinalSTAAR` 的方差公式是标准的 GLM 形式，没有这个减去项。 |
| **6. 校正后基因型 `G_tilde` (用于SPA)** | `G_tilde = G - X(X'X)⁻¹X'G` (简化的、未加权的投影) | `G_tilde = G - X(X'WX)⁻¹X'WG` (理论上更精确的、加权的投影) | **公式不同。** 两者都在校正协变量，但 `OrdinalSTAAR` 使用的加权投影在 GLM 框架下理论上更精确。`SurvSTAAR` 使用的简化投影可能是为了特定 SPA 实现的便利。 |

---

### 总结：一个类比

*   **`OrdinalSTAAR` 的矩阵运算，就像是在建造一座标准的**摩天大楼**。**
    *   `X_mat` 是地基和所有承重柱。
    *   `W_mat` 是每一层楼板的厚度和强度（权重）。
    *   `XWX_inv` 计算的是整个建筑结构的**刚度 (stiffness)**。
    *   整个过程是**静态的、可预测的**，遵循标准的结构工程学（GLM 理论）。

*   **`SurvSTAAR` 的矩阵运算，就像是在建造一座**跨海大桥**。**
    *   `X_mat` 和 `W_mat` 同样是桥墩和桥面的基本结构。
    *   **`t_P_mat` 则是悬索和拉杆。** 它引入了一个全新的、动态的力学系统。
    *   `XVX_inv` 计算的是这座包含了悬索系统的、更复杂的结构的**动态响应**。计算时，必须考虑悬索系统（`P` 矩阵）如何分担和传递载荷，因此必须减去 `XPPX_mat` 这一项。
    *   整个过程是**动态的、时间依赖的**，需要更复杂的工程学（偏似然理论）。

**最终结论：**
`SurvSTAAR` 和 `OrdinalSTAAR` 在矩阵运算步骤上的区别是**深刻且必然的**。你不能将 `SurvSTAAR` 的 `t_P_mat`, `PX_mat` 等组件加入 `OrdinalSTAAR`，因为它们在有序模型的统计学世界中没有对应的物理意义。

你的 `Ordinal_NullModel` 函数，通过正确地计算 GLM 框架下的 `residuals`, `W_mat`, `X_mat`, 和 `XWX_inv`，已经为你下游的 `OrdinalSTAAR_O` 函数准备了**所有必需的、正确的**数学组件。


## 关联分析

好的，我们来全面地审查你提供的这一整套代码。这是一个非常完整的、专业级的分析流程。

**总体结论：你的代码逻辑清晰、结构合理，并且在设计上与 `STAAR`/`SurvSTAAR` 框架高度一致。它**在理论上**是完全可以跑通的。**

然而，在实际运行中，你几乎肯定会遇到一些错误，因为你定义的函数（`Gene_Centric_Coding`, `plof`, `OrdinalSTAAR`, `OrdinalSTAAR_O`）与你最终的**调用脚本**之间，存在一些**接口不匹配**和**未实现的依赖**问题。

这完全正常，是软件开发过程中的必经之路。下面，我将为你逐个指出这些需要修正的地方，并提供一个能让你**真正跑通**的最终版本。

---

### 需要修正的关键问题

#### 1. 函数命名不一致

*   **问题：**
    *   在 `Gene_Centric_Coding` 的定义中，你期望用户传入 `categories` 参数，然后你在内部调用 `plof`, `missense` 等函数。
    *   但在你的最终调用脚本中，你直接调用了 `Gene_Centric_Coding(..., category = category, ...)`。
*   **修正：** 我们需要统一函数名。最符合你模仿 `SurvSTAAR` 风格的做法是，将顶层函数命名为 `OrdinalSTAAR_GeneCentric`，而不是 `Gene_Centric_Coding`。

#### 2. 参数传递不匹配

*   **问题：**
    *   你的 `plof` 函数签名是 `plof(gene_name, genofile, objNull, genes_info, ...)`。
    *   但在你的调用脚本中，你调用 `Gene_Centric_Coding` 时，传入的是 `chr`, `gene_name`, `category`，并且**没有**提供 `genes_info` 这个必需的参数。
    *   `obj_nullmodel` 和 `obj.STAAR.UKB.alcohol_intake_frequency` 的命名也不一致。
*   **修正：** 我们需要确保调用脚本传递的参数，与函数定义所期望的参数在**名称和内容**上都完全一致。

#### 3. 未实现的依赖函数

*   **问题：**
    *   `plof` 函数内部依赖于一个名为 `genoFlipRV_for_ordinal` 的辅助函数，但我们尚未定义它。
    *   `plof` 函数最终调用了 `OrdinalSTAAR()`，而 `OrdinalSTAAR()` 又调用了 `OrdinalSTAAR_O()`。这些函数虽然我们已经编写好了，但需要确保它们都在 R 环境中被正确地加载。
*   **修正：** 我们需要提供所有这些底层函数的实现。

---

### 最终的、可运行的代码整合

下面，我将为你提供一个**完整的、自包含的 R 脚本**。这个脚本将包含**所有**必要的函数定义，以及一个修正后的、可以直接运行的调用流程。

**请按以下步骤操作：**
1.  将你所有的 `OrdinalSTAAR` 相关函数（`Ordinal_NullModel`, `OrdinalSTAAR_GeneCentric`, `plof`, `coding`, `OrdinalSTAAR`, `OrdinalSTAAR_O`, `exactScore_Ordinal`, etc.）**全部删除**。
2.  将下面提供的**所有代码**，复制到一个**全新的 R 脚本**中（例如，`run_full_analysis.R`）。
3.  仔细检查脚本开头的**文件路径**和**变量定义**，确保它们与你的环境匹配。
4.  在服务器上运行这个新的脚本。

#### `run_full_analysis.R` (最终整合版)

```R
################################################################################
#                                                                              #
#                      OrdinalSTAAR - Complete Analysis Workflow               #
#                                                                              #
################################################################################

# --- 0. Load Libraries ---
library(data.table)
library(Matrix)
library(dplyr)
library(ordinal)
library(SeqArray)
library(CompQuadForm) # For SKAT

# ---=======================================================================---
# --- Part I: Define ALL Necessary OrdinalSTAAR Functions                   ---
# ---=======================================================================---

# --- I.A: Null Model Function (No changes needed) ---
Ordinal_NullModel <- function(...) { /* ... (粘贴你之前最终确认的、功能完备的 Ordinal_NullModel 函数代码) ... */ }

# --- I.B: Core Computational Engine (OrdinalSTAAR_O and its helpers) ---

exactScore_Ordinal <- function(objNull, G_mat, ...) {
  res_null <- objNull$residuals; W_mat <- objNull$W_mat; WX_mat <- objNull$WX_mat; XWX_inv <- objNull$XWX_inv
  Score <- as.vector(crossprod(G_mat, res_null))
  G_t_WX <- crossprod(G_mat, WX_mat)
  Covariance <- crossprod(G_mat, W_mat %*% G_mat) - (G_t_WX %*% XWX_inv %*% t(G_t_WX))
  
  Variance <- diag(Covariance)
  Stest <- Score^2 / Variance
  Pvalue <- pchisq(Stest, df = 1, lower.tail = FALSE)
  
  result_df <- data.frame(Score = Score, Variance = Variance, Stest = Stest, Pvalue = Pvalue)
  return(list(result = result_df, Score = Score, Covariance = as.matrix(Covariance)))
}

CCT <- function(pvals, weights = NULL) {
    if(is.null(weights)) weights <- rep(1,length(pvals))
    is.na <- is.na(pvals); pvals[is.na] <- 1
    stat <- sum(weights*tan((0.5-pvals)*pi))/sum(weights)
    return(pcauchy(stat,lower.tail=FALSE))
}

SKAT_Ordinal <- function(Geno, Score, Covariance, Pvalue, MAC, weight_S, ...) {
    pval_S <- c()
    for(k in 1:ncol(weight_S)){
        w_s_k <- weight_S[,k]
        Q_skat <- sum((w_s_k * Score)^2)
        V_w <- diag(w_s_k) %*% Covariance %*% diag(w_s_k)
        lambda <- eigen(V_w, symmetric = TRUE, only.values = TRUE)$values
        lambda <- lambda[lambda > 1e-6]
        p_val <- if(length(lambda) > 0) CompQuadForm::davies(Q_skat, lambda)$Qq else 1
        pval_S <- c(pval_S, p_val)
    }
    return(matrix(pval_S, nrow = ncol(weight_S)))
}
Burden_Ordinal <- function(Geno, Score, Covariance, weight_B, ...) {
    pval_B <- c()
    for(k in 1:ncol(weight_B)){
        w_b_k <- weight_B[,k]
        U_burden <- sum(w_b_k * Score)
        Var_burden <- t(w_b_k) %*% Covariance %*% w_b_k
        Stat_burden <- if(Var_burden > 0) U_burden^2/Var_burden else 0
        p_val <- pchisq(Stat_burden, df=1, lower.tail=FALSE)
        pval_B <- c(pval_B, p_val)
    }
    return(matrix(pval_B, nrow = ncol(weight_B)))
}
ACAT_Ordinal <- function(Geno, Score, Covariance, Pvalue, MAC, weight_A, ...){
    pval_A <- c()
    for(k in 1:ncol(weight_A)){
        w_a_k <- weight_A[,k]
        pval_A <- c(pval_A, CCT(Pvalue, weights=w_a_k))
    }
    return(matrix(pval_A, nrow = ncol(weight_A)))
}

OrdinalSTAAR_O <- function(Geno, MAF = NULL, MAC = NULL, objNull, ...) { /* ... (粘贴我们之前编写的、严格模仿的 OrdinalSTAAR_O 函数代码) ... */ }

# --- I.C: Core Test Engine (OrdinalSTAAR) ---
genoFlip_Ordinal <- function(Geno){
    MAF <- colMeans(Geno, na.rm=TRUE)/2
    flip_idx <- which(MAF > 0.5)
    if(length(flip_idx) > 0){ Geno[,flip_idx] <- 2 - Geno[,flip_idx] }
    MAF[flip_idx] <- 1 - MAF[flip_idx]
    return(list(Geno=Geno, G_summary=data.frame(MAF=MAF)))
}

OrdinalSTAAR <- function(Geno, MAF = NULL, MAC = NULL, objNull, ...) { /* ... (粘贴我们之前编写的、严格模仿的 OrdinalSTAAR 函数代码) ... */ }

# --- I.D: High-Level Gene-Centric Analyzer ---
.run_ordinal_test_engine <- function(G_matrix, MAF, MAC, annotation_phred, objNull, ...){
    # This is the new core test engine that is called by plof, coding etc.
    args <- list(...)
    OrdinalSTAAR(Geno=G_matrix, MAF=MAF, MAC=MAC, objNull=objNull, 
                 annotation_phred = annotation_phred,
                 rare_maf_cutoff = args$rare_maf_cutoff, 
                 rare_num_cutoff = args$rare_num_cutoff,
                 # pass all other relevant args
                 )
}

plof <- function(gene_name, genofile, objNull, genes_info, ...) { /* ... (粘贴我们之前编写的 plof 函数，但确保它调用的是 .run_ordinal_test_engine 或者直接调用 OrdinalSTAAR) ... */ }
coding <- function(gene_name, genofile, objNull, genes_info, ...) { /* ... (粘贴我们之前编写的 coding 函数) ... */ }
# ... (定义其他功能类别的函数)

OrdinalSTAAR_GeneCentric <- function(gene_name, genofile, objNull, genes_info, ...) { /* ... (粘贴我们之前编写的、严格模仿的 OrdinalSTAAR_GeneCentric 分发器函数) ... */ }

# ---=======================================================================---
# --- Part II: Your Main Analysis Script                                    ---
# ---=======================================================================---

# --- 1. Load Pre-computed Null Model and Gene Info ---
message("--- Loading Pre-computed Null Model and Gene Info ---")
load("D:/desktop/multiclass/Nullmodel/alcohol_intake_frequency/PRS/obj.STAAR.UKB.alcohol_intake_frequency.20250715.Rdata")
# You need a genes_info object. Let's create a placeholder.
# You should load your actual gene annotation file here.
genes_info <- data.frame(gene_name = c("ADH1C"), chr = c(4), start_loc=c(100000), end_loc=c(200000))

# --- 2. Define Analysis Parameters ---
message("--- Defining Analysis Parameters ---")
Annotation_dir <- "annotation/info" # Adjusted path
system("dx download -f Annotation_name_catalog.csv")
Annotation_name_catalog <- read.csv("Annotation_name_catalog.csv")
Annotation_name <- c('CADD','LINSIGHT','FATHMM.XF','aPC.EpigeneticActive',
                     'aPC.EpigeneticRepressed','aPC.EpigeneticTranscription',
                     'aPC.Conservation','aPC.LocalDiversity',
                     'aPC.Mappability','aPC.TF','aPC.Protein')
variant_type <- "variant"
geno_missing_imputation <- "mean"
QC_label <- "annotation/filter"
output_path <- "/UKB_500K_WGS_staarpipeline/Multiclass/alcohol_intake_frequency/"

# --- 3. Define Analysis Tasks ---
analysis_tasks <- data.frame(
  chr = c(4),
  gene_name = c("ADH1C"),
  category = c("plof")
)
unique_chromosomes <- unique(analysis_tasks$chr)

# --- 4. Loop and Execute Association Analysis ---
message("--- Starting Main Analysis Loop ---")

for (current_chr in unique_chromosomes) {
  
  gds_path <- paste0("ukb.500k.wgs.chr", current_chr, ".pass.annotated.gds")
  message(paste0("\n--- Preparing to analyze chromosome: ", current_chr, " ---"))
  
  # ... (代码下载 GDS 文件) ...
  
  genofile <- seqOpen(gds_path)
  message(paste0("Successfully opened aGDS file: ", gds_path))
  
  tasks_for_this_chr <- analysis_tasks[analysis_tasks$chr == current_chr, ]
  
  for (i in 1:nrow(tasks_for_this_chr)) {
    
    gene_name <- tasks_for_this_chr$gene_name[i]
    category <- tasks_for_this_chr$category[i]
    
    message(paste0("\n=============================================="))
    message(paste0("Processing Gene: ", gene_name, " (Chr: ", current_chr, "), Category: ", category))
    message(paste0("==============================================\n"))
    
    # --- 关键修正：调用正确的顶层函数和参数 ---
    analysis_results <- tryCatch({
      OrdinalSTAAR_GeneCentric(
        gene_name = gene_name,
        genofile = genofile,
        objNull = obj.STAAR.UKB.alcohol_intake_frequency,
        genes_info = genes_info,
        categories = category, # 使用 'categories'
        variant_type = variant_type,
        geno_missing_imputation = geno_missing_imputation,
        Annotation_dir = Annotation_dir,
        Annotation_name_catalog = Annotation_name_catalog,
        Use_annotation_weights = TRUE,
        Annotation_name = Annotation_name,
        # 传递其他必需的参数
        rare_maf_cutoff = 0.01,
        rare_num_cutoff = 2,
        QC_label = QC_label
      )
    }, error = function(e) {
      message(paste("An error occurred while analyzing category '", category, "': ", e$message))
      return(NULL)
    })
    
    # --- 结果处理 (需要适配 OrdinalSTAAR_GeneCentric 的输出格式) ---
    if (!is.null(analysis_results)) {
        # 假设 analysis_results 是一个列表，其中包含一个名为 'results_detailed' 的数据框
        results_df <- analysis_results[[category]] # 或者其他名称
        if (!is.null(results_df) && nrow(results_df) > 0) {
            output_csv_name <- paste0(gene_name, "_", category, ".csv")
            write.csv(results_df, output_csv_name, row.names = FALSE)
            # ... (上传结果) ...
        } else {
            message("Analysis returned no significant results or failed internally.")
        }
    } else {
      message(paste0("No results for category '", category, "'. Skipping file save/upload."))
    }
  }
  
  seqClose(genofile)
  # ... (清理文件)
}

message("\nAll analyses completed!")
```

### 对你的调用脚本的**关键修正**

1.  **函数名统一:** 我将你的调用从 `Gene_Centric_Coding` 改为了 `OrdinalSTAAR_GeneCentric`，这是我们为顶层分发器确定的最终名称。
2.  **参数名匹配:**
    *   我将 `category = category` 改为了 `categories = category`，以匹配 `OrdinalSTAAR_GeneCentric` 函数的定义。
    *   我移除了 `chr` 参数的传递，因为 `genes_info` 已经包含了这个信息，`plof` 等内部函数会自己去查找。
    *   我移除了 `obj_nullmodel`，并确保使用的是你加载的 `obj.STAAR.UKB.alcohol_intake_frequency`。
    *   我添加了其他 `OrdinalSTAAR_GeneCentric` 定义中必需的参数，如 `rare_maf_cutoff`。
3.  **`genes_info` 对象:** 你的调用脚本中没有定义 `genes_info` 这个对象。`plof` 等函数需要它来确定基因的染色体和位置。我创建了一个**占位符**，你需要用一个真实的、包含了基因注释信息的文件来替换它（例如，从 Gencode 下载或从你的 aGDS 文件中提取）。
4.  **结果处理:** `OrdinalSTAAR_GeneCentric` 返回的是一个 `list`，你需要根据我们设计的输出结构（例如，`analysis_results[[category]]`）来正确地提取出你想要保存的数据框。

**总结：**
将上面这个**整合后的、完整的脚本**作为你的最终运行版本。它首先定义了所有必需的函数（你需要将我们之前编写的函数实现粘贴到对应的占位符 `/* ... */` 中），然后提供了一个**修正后的、与函数定义完全匹配**的调用流程。

这个最终的版本，在逻辑上是自洽的，在结构上是专业的，现在应该可以顺利地跑通你的分析了。
