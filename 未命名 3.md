好的，这是对您提供的幻灯片（PPT）所有文字内容的中文翻译。

---

### **第1页**

**标题页**

**大规模测序数据中有序性状关联分析的高效策略**

**管源源 (Yuanyuan Guan)**

**2025年7月3日**

---

### **第3页**

**现有方法的局限性**

**有序性状的普遍性:**
许多重要的性状本质上是有序的。

**现有方法（如SAIGE-GENE+）的处理方式:**
**作为定量性状处理:**
将有序类别（例如，1, 2, 3, 4, 5）强制转换为等距的定量尺度。这违反了统计学假设，可能导致I类错误率膨胀，即假阳性增多。
**二分化性状:**
将多个类别合并为两个（例如，不饮酒者 vs. 饮酒者）。这会丢弃原始数据中丰富的表型信息，从而导致统计功效的损失。

---

### **第4页**

**本文提出的解决方案 - POLMM-GENE+**

正如 Bi 等人 (2023) 所指出的，他们开发了 POLMM-GENE+ 来解决这个问题。他们的方法基于 **比例优势逻辑混合模型 (Proportional Odds Logistic Mixed Model, POLMM)**，该模型可以：

*   准确地模拟表型的分类性质。
*   使用混合模型框架来控制样本亲缘关系。
*   通过避免不当数据转换造成的信息损失来保持统计功效。

---

### **第5页**

**我们的解决方案**

---

### **第6页**

**零模型：两阶段分析法**

我们的研究建立了一个创新的两阶段分析流程。

在第一阶段，我们为有序性状构建一个高质量的零模型，该模型不仅在统计上严谨，而且能有效整合对亲缘关系的校正。

在第二阶段，这个零模型被无缝集成到已建立的稀有变异分析工具 STAAR 中，以进行高效的全基因组关联检验。

---

### **第7页**

**阶段一：构建统计上稳健且计算高效的零模型**

**核心模型选择:**
比例优势模型 (Proportional Odds Model)

**实现方法:**
我们使用了R语言中的 `ordinal::clm` 函数，将饮酒频率建模为一个有序因子，同时纳入了基本协变量（年龄、性别、年龄的平方）和前10个主成分 (PCs) 来校正群体分层。

---

### **第8页**

**阶段一：构建统计上稳健且计算高效的零模型（代码页）**

```R
fit_null_model <- function(fixed, data, family, id, ...){

  is_ordinal <- is.character(family) && family == "ordinal"

  if (is_ordinal) {
    message("正在拟合有序回归模型并为 GMMAT/STAAR 做准备...")
    outcome_var_name <- as.character(fixed[[2]])

    if (!is.ordered(data[[outcome_var_name]])) {
      stop(paste("对于 'ordinal' family，结果变量 '", outcome_var_name, "' 必须是一个有序因子。"))
    }
    
    # 使用clm拟合有序模型，确保保存模型框架
    clm_fit <- ordinal::clm(formula = fixed, data = data, model = TRUE, ...)
    
    # 将拟合的clm对象传递给我们特有的转换函数
    obj_nullmodel <- create_null_from_clm(clm_obj = clm_fit, data = data, id_col = id)

  } else {
    # 对于所有其他family类型，使用标准的GMMAT函数进行GLM（因为kins=NULL）
    message("正在拟合广义线性模型 (如果提供了kins，则为GLMM)...")
    obj_nullmodel <- GMMAT::glmmkin(fixed = fixed, data = data, kins = NULL, id = id, family = family, ...)
  }
  
  return(obj_nullmodel)
}
```

---

### **第9页**

**阶段一(1)：通过累积二分法进行表型二值化**

(此页显示了一个数据框的快照，展示了原始的有序性状 `alcohol_intake_frequency` 以及经过处理后的数值和二值化列。)

**部分列名翻译:**
*   `userId`: 用户ID
*   `alcohol_intake_frequency`: 饮酒频率
*   `sex`: 性别
*   `age`: 年龄
*   `alcohol_ordinal`: 饮酒频率（有序数值）
*   `alcohol_bin_1` 到 `alcohol_bin_5`: 二值化饮酒频率变量1到5

**部分数据值翻译:**
*   `Once or twice a week`: 每周一到两次
*   `Three or four times a week`: 每周三到四次
*   `Never`: 从不
*   `Female`: 女性
*   `Male`: 男性

---

### **第10页**

**阶段一(2)：使用REGENIE的多性状模式生成多基因预测**

我们利用了 REGENIE 强大的多性状二元模式 (`--bt`)。生成的5个二值化性状被同时提供在一个表型文件中。然后，我们执行一次 REGENIE 的步骤一，便可为所有5个性状高效地并行计算出全基因组的、留一染色体法 (Leave-One-Chromosome-Out, LOCO) 的预测值。

(以下为命令行代码，保持原文)
```bash
conda activate regenie_env
regenie \
--step 1 \
--bed /datapool/maths/UKBB/UKB_genotypes_QCed_ZHL/chrall \
--phenoFile /datapool/home/2024102311/UKB/nullmodels/multiclass/alcohol_intake_frequency/binary_regenie_combina \
--covarFile /datapool/home/2024102311/UKB/nullmodels/multiclass/alcohol_intake_frequency/binary_regenie_combinat \
--covarColList sex,age,age2,PC1,PC2,PC3,PC4,PC5,PC6,PC7,PC8,PC9,PC10 \
--catCovarList sex \
--bt \
--bsize 1000 \
--out /datapool/home/2024102311/UKB/nullmodels/multiclass/alcohol_intake_frequency/binary_regenie_combination \
--threads 8 \
--print-prs
```

---

### **第11页**

**阶段一(3)：通过PCA进行降维**

REGENIE 的输出：步骤二为每个二值化性状生成了5个独立的 `.loco` 文件。每个文件包含22行（对应1-22号染色体）和对应每个样本的列，其中包含了该个体的遗传预测值。

(以下为R代码输出，翻译了注释和表头)
```R
summary(pca_result)
# 各主成分的重要性：
#                    PC1      PC2      PC3      PC4      PC5       PC6       PC7
# 标准差           7.5761   4.6536   3.6488   2.79237  2.27723  0.55381   0.44282
# 方差贡献率       0.5218   0.1969   0.1210   0.07089  0.04714  0.00279   0.00178
# 累计方差贡献率   0.5218   0.7187   0.8397   0.91059  0.95773  0.96052   0.96230

keep_num <- 5 # 选择5个主成分
pca <- as.data.frame(pca_result$x[, 1:keep_num])
colnames(pca) <- paste0("regenie", 1:keep_num)
head(pca)
#    regenie1    regenie2    regenie3   regenie4    regenie5
# 1 -4.162050    6.430704   11.514053 -3.6421994   4.8328743
# 2 -2.199622   -6.672245   -0.847344 -0.8641354   2.1394649
# 3  6.205353   -5.901825   -5.368471  3.2509371   0.3248081
# 4  8.828008    3.386830    2.679228  3.3951742   2.8530557
# 5 -8.963374   -3.385161    3.306665 -2.1963141  -4.9052987
# 6 20.258823   10.834167    1.791677 -0.3006973  -4.6836191
```

---

### **第12页**

**阶段一(4)：协变量整合**

**最终模型公式:**
饮酒频率 ~ 年龄 + 性别 + 主成分(1-10) + REGENIE主成分(1-5)

---

### **第13页**

**问题：我们为什么选择.loco文件而不是.prs文件？**

**1. .loco 文件：留一染色体法预测**

**它是什么：** 当 REGENIE 计算染色体 k 上的一个变异的关联性时，用于校正的多基因背景预测是利用除染色体 k 之外的所有其他染色体上的SNP构建的。

**目的：避免近端污染 (Proximal Contamination)。**
如果遗传预测包含了与被测变异来自同一染色体的信息，特别是那些与被测变异处于连锁不平衡 (LD) 的SNP，那么这个协变量本身就会与检验变异相关。这将导致过度校正和统计功效的严重损失。

---

### **第14页**

**问题：选择 .loco 还是 .prs？**

**2. .prs 文件：多基因风险评分**

**它是什么：** 这个分数是使用来自整个基因组（所有染色体）的SNP为每个个体计算的。它代表了个体对某一性状的、总体的、全基因组范围的遗传易感性。

**预期用途：**
`.prs` 文件主要用于下游应用，例如：
*   在独立的验证数据集中验证PRS模型的预测能力。
*   根据个体的遗传风险对其进行分层。
*   在其他类型的研究中，将其用作代表整体遗传效应的协变量。

---

### **第15页**

**问题：选择 .loco 还是 .prs？**

**关联检验 (Association Testing):**
目标是发现新的基因-性状关联。为了确保统计功效，必须使用 `.loco` 预测来避免过度校正。这是我们目前正在做的事情。

**遗传预测 (Genetic Prediction):**
目标是建立一个最优模型来预测个体的表型。在这种情况下，应该使用 `.prs` 文件，因为它包含了来自整个基因组的最完整信息。

---

### **第16页**

**阶段二：模型对象的“转换”与兼容性工程**

**挑战:**
`ordinal::clm` 的输出对象不能被 STAAR 直接使用。

**我们的解决方案 (create_null_from_clm 函数):**
步骤1：通过 van der Waerden 正态得分进行表型转换；
步骤2：通过结构模拟来复制一个 glm 对象。

---

### **第17页**

**阶段二(1)：通过 van der Waerden 正态得分进行表型转换**

**计算条件概率:**
利用已拟合的 `clm` 对象，我们首先计算每个个体在给定其协变量的情况下，落入各个有序类别的预测概率。

**应用 van der Waerden (VdW) 正态得分:**
然后，我们将有序表型转换为一个连续变量。每个类别的得分被计算为一个标准正态变量的期望值，该变量的取值条件是落在由该类别边际概率所定义的Z分数分位数之间。

**结果：一个新的连续表型**

---

### **第18页**

**阶段二(2)：通过结构模拟来复制一个 glm 对象**

利用新的连续表型，我们构建了一个列表对象，该对象精确复制了 `glm()` 函数返回对象的内部结构。

**决定性步骤：构建 `$qr` 部分**
我们生成了一个标准的（带截距项的）设计矩阵，并利用上一步计算出的权重，对其进行了一次加权QR分解 (`qr(sqrt(weights) * X_glm)`)。

**为什么这很关键：** 像 SKAT（STAAR所依赖的）这样的软件包，其底层的统计机制并不仅仅是简单地对矩阵求逆。为了数值稳定性和计算效率，它通常直接使用 `glm` 对象的 `$qr` 部分。

---

### **第19页**

**阶段二(2)：通过结构模拟来复制一个 glm 对象（代码页）**

```R
obj_nullmodel <- list(
  # --- 标准GMMAT/STAAR组件 ---
  id_include       = as.character(sample_ids),
  # theta          = tau,
  n.pheno          = 1,
  n.groups         = 1,
  coefficients     = alpha,
  linear.predictors = eta,
  fitted.values    = mu,
  residuals        = residuals,
  relatedness      = FALSE,
  sparse_kins      = FALSE,
  converged        = clm_obj$convergence$code == 0,

  # --- STAAR中GLM路径的核心组件 ---
  y                = y_numeric,
  weights          = weights_squared,
  family           = gaussian(link = "identity"),

  # --- 为兼容R的泛型函数所需的关键元数据 ---
  model            = model_data,
  terms            = clm_obj$terms,
  formula          = formula(clm_obj),
  call             = clm_obj$call,

  # --- 为增强稳健性而基于QR新增/更新的组件 ---
  qr               = qr_obj,
  rank             = qr_obj$rank,
  df.residual      = n_obs - qr_obj$rank,
  cov              = chol2inv(qr_obj$qr)
)
```

---

### **第20页**

**以基因为中心的关联分析**

---

### **第21页**

**以基因为中心的关联分析（结果页）**

(此页显示了两个分析结果表，是对 `ADH1C` 基因在不同功能类别下的关联分析结果)

**表头翻译:**
*   `Gene name`: 基因名称
*   `Chr`: 染色体
*   `Category`: 类别
*   `#SNV`: 单核苷酸变异数量
*   `cMAC`: 累积次要等位基因计数
*   `ACAT-O`, `STAAR-O`: (检验方法名称，保留原文)

**类别 (Category) 翻译:**
*   `missense`: 错义
*   `plof`: 功能丧失预测
*   `plof_ds`: 功能丧失预测 (ds)
*   `ptv`: 蛋白质截短变异
*   `ptv_ds`: 蛋白质截短变异 (ds)
*   `synonymous`: 同义
*   `downstream`: 下游
*   `upstream`: 上游
*   `UTR`: (基因非翻译区，保留原文)
*   `promoter_CAGE`: 启动子 (CAGE)
*   `promoter_DHS`: 启动子 (DHS)
*   `enhancer_CAGE`: 增强子 (CAGE)
*   `enhancer_DHS`: 增强子 (DHS)

---

### **第22页**

**未来方向**

*   零模型列表 (nullmodel list)
*   SPA (鞍点近似法)