
---
### 一、导入------方法概括

#### 1. 二分类表型：广义线性混合模型 (GLMM)

*   **广义 (Generalized)**: 因为表型不是标准正态分布的。对于二分类表型，是逻辑回归；对于您的有序表型，理论上可以是**有序probit模型**。
*   **线性 (Linear)**: 协变量和遗传效应仍然是线性组合。
*   **混合 (Mixed)**: 这是最关键的一点。模型中包含**两种效应**：
    *   **固定效应 (Fixed Effects)**: 我们想要直接估计其效应大小的变量，如年龄、性别、基因型 `G` 等。
    *   **随机效应 (Random Effects)**: 用于解释样本之间由于**亲缘关系**和**群体结构**导致的表型相关性。这通常通过一个基于**遗传关系矩阵 (GRM)** 的随机效应项来实现。

#### 2. 有序多分类表型：REGENIE得到的PRS解释样本亲缘关系，从而近似GLMM中的随机效应项。

优势：
- 计算效率高
- 比GLM更准确


---

### 二、具体工作流程

#### 第1步: 得到fullDat：phenotype、covariates、PC1-10

2.  **表型转换**:        ```
    *   **二分类化**: 这是为了给 `REGENIE` 准备输入。代码将6个等级的有序表型，巧妙地转换为了**5个**相关的二分类表型：
        *   `alcohol_bin_1`: 从不 vs. 喝酒 (Y ≤ 1 vs. Y > 1)
        *   `alcohol_bin_2`: 偶尔或更少 vs. 喝得更频繁 (Y ≤ 2 vs. Y > 2)
        *   `alcohol_bin_3`: 每月1-3次或更少 vs. 更频繁 (Y ≤ 3 vs. Y > 3)
        *   ... 以此类推。

3.  **协变量处理**:
    *   创建了年龄的平方项 `age2` 以捕捉非线性效应。
    *   对所有连续的协变量（`age`, `age2`, `PC1-10`）进行了**标准化 (scaling)**。

#### 第2步: 使用 REGENIE 计算个体水平预测值 (PRS)

1.  **运行 REGENIE (Step 1)**:
    *   在这一步中，`REGENIE` 会利用**全基因组**的常见变异信息（来自 `--bed` 文件指定的PLINK格式数据），对**每一个**二分类饮酒表型分别构建一个复杂的全基因组回归模型。
    *   **关键产物**: `REGENIE` 会为**每个参与者**和**每个二分类表型**，计算出一个**个体水平的遗传预测值**。这个预测值本质上就是一个**多基因风险评分 (PRS)**。
    *   最终得到5个独立的PRS文件。
    * 注意：这里保留了LOCO文件，LOCO=TRUE时，会给出具体的染色体。

#### 第3步: ==PRS 的正交化== 

1.  **问题**: 这5个PRS分数之间**高度相关**，会引起**多重共线性**。
2.  **解决方案**: 使用**主成分分析 (PCA)**。
3.  **最终数据**: 将这5个新的、正交的PRS主成分 `prs_pc` 作为新的协变量添加到fullDat中，得到最终用于拟合零模型的数据 `data_for_null_model`。

#### 第7步: 拟合 OrdinalSTAAR 零模型

1.  **定义模型**:
    *   **结局变量 (`outcomeCol`)**: `alcohol_intake_frequency` (原始的、6个等级的有序变量)。
    *   **基础协变量 (`covCol`)**: `sex`, `age`, `age2`, `PC1-10`。
    *   **PRS协变量 (`PRSCol`)**: `prs_pc1` 到 `prs_pc5` (5个正交的PRS主成分)。
2.  **调用 `NullModel`**:
    *   代码最后调用了自己开发的 `OrdinalSTAAR::NullModel` 函数。



---
### 三、OrdinalSTAAR::NullModel(...) 

参考：[SurvSTAAR/R/NullModel.R at main · Cui-yd/SurvSTAAR](https://github.com/Cui-yd/SurvSTAAR/blob/main/R/NullModel.R)

**核心目标**: 该函数旨在拟合一个**有序多分类表型的零模型**，并预先计算出后续进行`OrdinalSTAAR`所必需的所有组件。

---
#### Part 1: 拟合有序零模型 ordinal::clm(...）

#### Part 2: 计算残差和方差组件（潜变量残差法）

*   为后续的分数检验准备必需的组件。
*   **实现**:
    1.  **计算潜变量残差**:
        *   `eta <- X_mat %*% alpha_coefs`: 计算每个人的线性预测值 `Xβ`。
        *   `lower_b`, `upper_b`: 根据每个人的观测类别，确定其潜在误差 `ε` 被截尾的区间 `[a, b]`。
        *   `residuals <- (dnorm(lower_b) - dnorm(upper_b)) / prob_interval`: 应用**截尾正态分布的条件期望公式** `[φ(a) - φ(b)] / [Φ(b) - Φ(a)]`，计算出每个人的潜变量残差。
    2.  **计算条件方差和权重**:
        *   `var_y <- 1 + term1 - residuals^2`: 应用**截尾正态分布的条件方差公式**，计算出每个人的潜在变量的条件方差。
        *   `W_mat <- Diagonal(x = 1 / var_y)`: 创建权重矩阵 `W`，其对角线元素是条件方差的倒数。
    3.  **预计算矩阵**:
		- `X_t_W <- crossprod(X_mat, W_mat)`
        * `XWX_mat <- X_t_W %*% X_mat`
        * `XWX_inv <- solve(XWX_mat)`
        * `WX_mat <- t(X_t_W)`
        * 预先计算好分数检验方差公式 `Var(U) = G'WG - G'WX(X'WX)⁻¹X'WG` 中所有与基因型无关的、耗时的部分.

#### Part 3: 组装

1.  `base_list <- list(...)`: 创建一个包含所有核心组件的列表。
2.   根据 `LOCO` 参数，添加 `LOCO = TRUE` 或 `LOCO = FALSE` 标志，并相应地记录染色体 `chr`。这告诉下游函数这个零模型是用于全基因组分析还是LOCO分析。
3.  待完成：如果 `use_SPA = TRUE`，代码会调用 `CGF4LatentRes` 函数来额外计算用于鞍点近似的累积生成函数。
4.  `return(fit_null)`: 返回这个包含了所有信息的、可以直接被 `OrdinalSTAAR` 等函数使用的最终对象。



---

### 四、OrdinalSTAAR::Ordinal_GeneCentricCoding(...) 

参考：[SurvSTAAR/R/GeneCentricCoding.R at main · Cui-yd/SurvSTAAR](https://github.com/Cui-yd/SurvSTAAR/blob/main/R/GeneCentricCoding.R)

![[Pasted image 20250910205817.png]]

基本没有改动


### 五、OrdinalSTAAR::Ordinal_plof(...) 

参考：[SurvSTAAR/R/plof.R at main · Cui-yd/SurvSTAAR](https://github.com/Cui-yd/SurvSTAAR/blob/main/R/plof.R)











### 六、OrdinalSTAAR::OrdinalSTAAR(...) 

参考：[SurvSTAAR/R/SurvSTAAR.R at main · Cui-yd/SurvSTAAR](https://github.com/Cui-yd/SurvSTAAR/blob/main/R/SurvSTAAR.R)

基本没有改动

### 七、OrdinalSTAAR::OrdinalSTAAR(...) 