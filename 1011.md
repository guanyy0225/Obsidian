### fitted_probs如何用fit()得到，现在是手动计算的

1. `predict` 泛型函数可用于 `clm` 对象，`fitted`泛型函数不可用于`clm` 对象。
2. predict无法产生矩阵，只能产生向量？

![[Pasted image 20251011155445.png]]

3. 添加newdata后解决。
```R
model_data_no_outcome <- model_data[, colnames(model_data) != outcomeCol, drop = FALSE]
fitted_probs <- predict(clm_obj, newdata = model_data_no_outcome, type = "prob")$fit
```

4. latent这种情况也出现了报错
![[Pasted image 20251011192736.png]]
5. 残差和残差的方差计算也进行了优化
![[Pasted image 20251011194848.png]]

6. 理论精确版
好的，这是一个绝佳的请求。您提供的这个函数 (`NullModel_Fisher版`) 是一个非常精密的统计计算实现。为了完全理解它，我们需要分两步走：

7.  **第一步：奠定数学原理** —— 我们将使用LaTeX详细阐述其背后的统计理论，即有序回归模型的对数似然函数、得分（Score）以及Fisher信息矩阵。
8.  **第二步：逐行代码解析** —— 我们将函数中的每一块代码与相应的数学公式对应起来，解释代码是如何实现这些理论的。

---

### 第一部分：数学原理 (The Mathematical Foundation)

我们要处理的是**比例优势模型 (Proportional Odds Model)**，它是有序逻辑斯谛回归 (ordinal logistic regression) 的一种。

#### 1. 模型定义

对于一个个体 $i$ 和一个有序响应变量 $Y_i$，其取值为 $k \in \{1, 2, ..., J\}$。模型的核心是累积概率：
$$
P(Y_i \le k) = \mu_{ik}
$$
使用 **logit** 链接函数，我们有：
$$
\text{logit}(\mu_{ik}) = \log\left(\frac{\mu_{ik}}{1-\mu_{ik}}\right) = \theta_k - \eta_i \quad \text{for } k=1, \dots, J-1
$$
其中：
*   $\theta_k$ 是第 $k$ 个类别的**阈值 (threshold)** 或截距，满足 $\theta_1 < \theta_2 < \dots < \theta_{J-1}$。
*   $\eta_i = \mathbf{x}_i^T \boldsymbol{\beta}$ 是与协变量相关的**线性预测值 (linear predictor)**。
    *   $\mathbf{x}_i$ 是个体 $i$ 的协变量向量（长度为 $p$）。
    *   $\boldsymbol{\beta}$ 是协变量的系数向量（长度为 $p$）。

从累积概率，我们可以得到属于某个特定类别的概率 $\pi_{ik} = P(Y_i = k)$：
$$
\pi_{ik} = \mu_{ik} - \mu_{i, k-1} \quad \text{其中 } \mu_{i0} = 0 \text{ 且 } \mu_{iJ} = 1
$$
我们可以用 `plogis` 函数来表示 $\mu_{ik}$：
$$
\mu_{ik} = \text{plogis}(\theta_k - \eta_i) = \frac{1}{1 + e^{-(\theta_k - \eta_i)}}
$$

#### 2. 对数似然函数 (Log-Likelihood)

模型的总对数似然函数 $\ell$ 是所有 $n$ 个独立观测的对数似然之和：
$$
\ell(\boldsymbol{\theta}, \boldsymbol{\beta}) = \sum_{i=1}^n \sum_{k=1}^J I(Y_i=k) \log(\pi_{ik})
$$
其中 $I(Y_i=k)$ 是一个指示函数，如果个体 $i$ 的响应是类别 $k$，则为1，否则为0。

#### 3. Fisher信息矩阵 (Fisher Information Matrix)

Score检验的方差是基于**Fisher信息矩阵** $I$ 的。这个矩阵是**对数似然函数二阶导数（Hessian矩阵）的负期望**。它衡量了参数估计的精度。对于我们的模型，参数是 $(\boldsymbol{\theta}, \boldsymbol{\beta})$，所以信息矩阵是一个分块矩阵：
$$
I(\boldsymbol{\theta}, \boldsymbol{\beta}) =
\begin{pmatrix}
I_{\theta\theta} & I_{\theta\beta} \\
I_{\beta\theta} & I_{\beta\beta}
\end{pmatrix}
=
\begin{pmatrix}
\mathbf{D} & \mathbf{B}^T \\
\mathbf{B} & \mathbf{A}
\end{pmatrix}
$$
其中：
*   $\mathbf{D} = I_{\theta\theta}$ 是一个 $(J-1) \times (J-1)$ 的矩阵，表示阈值参数之间的信息。
*   $\mathbf{A} = I_{\beta\beta}$ 是一个 $p \times p$ 的矩阵，表示协变量系数之间的信息。
*   $\mathbf{B} = I_{\beta\theta}$ 是一个 $p \times (J-1)$ 的矩阵，表示协变量系数和阈值参数之间的**协方差信息**。

这些分块的元素可以通过对 $\ell$ 求导得到，其具体形式为：
$$
A_{rs} = \sum_{i=1}^n \frac{1}{\sigma_i^2} x_{ir} x_{is} \quad \text{其中 } \frac{1}{\sigma_i^2} = \sum_{k=1}^J \frac{(w_{ik})^2}{\pi_{ik}} \quad \text{且 } w_{ik} = \frac{\partial \pi_{ik}}{\partial \eta_i}
$$
$$
D_{jk} = \sum_{i=1}^n \sum_{l=1}^J \frac{1}{\pi_{il}} \frac{\partial \pi_{il}}{\partial \theta_j} \frac{\partial \pi_{il}}{\partial \theta_k}
$$
$$
B_{rj} = \sum_{i=1}^n \sum_{k=1}^J \frac{x_{ir}}{\pi_{ik}} \frac{\partial \pi_{ik}}{\partial \eta_i} \frac{\partial \pi_{ik}}{\partial \theta_j}
$$

#### 4. 参数的方差-协方差矩阵

所有参数 $(\boldsymbol{\theta}, \boldsymbol{\beta})$ 的方差-协方差矩阵 $\mathbf{V}$ 就是Fisher信息矩阵的逆：
$$
\mathbf{V} = I(\boldsymbol{\theta}, \boldsymbol{\beta})^{-1}
$$
`vcov(clm_obj)` 函数返回的就是这个 $\mathbf{V}$ 矩阵。您的代码**手动地、从第一性原理出发**，构建了 $I$ 矩阵，然后求逆得到 $\mathbf{V}$。

---

### 第二部分：代码解析 (Code Explanation)

现在，我们将 `NullModel_Fisher版` 的代码与上面的数学公式一一对应。

```R
# --- Part 3: 预计算 (真正无近似的 Fisher Information Matrix) ---
# ...
# [计算 eta, mu_star_mat, pi_mat 的代码]
# 这些代码块分别计算了 η_i, μ_ik, 和 π_ik。
# mu_star_mat 对应 μ_i,1, ..., μ_i,J-1
# pi_mat 对应 π_i,1, ..., π_i,J
```
这部分是基础准备工作，完美地实现了模型定义中的核心变量。

```R
# J_minus_1 <- J - 1
# f_mat <- mu_star_mat * (1 - mu_star_mat)
```
*   **`f_mat`**: 这是一个关键的中间变量。对于logit链接，累积概率 $\mu_{ik}$ 对线性预测值 $\eta_i$ 的导数是 $\frac{\partial \mu_{ik}}{\partial \eta_i} = -\mu_{ik}(1-\mu_{ik})$。这里的 `f_mat` 计算了 $\mu_{ik}(1-\mu_{ik})$。

```R
# D_mat <- matrix(0, nrow = J_minus_1, ncol = J_minus_1)
# if (J > 1) {
#   for (j in 1:J_minus_1) {
#     for (k in j:J_minus_1) { ... }
#   }
# }
```
*   **`D_mat`**: 这段代码正在**精确地构建 $I_{\theta\theta}$ (即 $\mathbf{D}$) 矩阵**。
    *   $\frac{\partial \pi_{ik}}{\partial \theta_j}$ 只在 $k=j$ 和 $k=j+1$ 时非零。
    *   `if (j == k)`: 计算 $\mathbf{D}$ 矩阵的**对角线元素** $D_{jj}$。它涉及到 $\frac{\partial \pi_{ij}}{\partial \theta_j}$ 和 $\frac{\partial \pi_{i,j+1}}{\partial \theta_j}$。
    *   `else if (k == j + 1)`: 计算 $\mathbf{D}$ 矩阵的**次对角线和超对角线元素** $D_{j,j+1}$。它涉及到 $\frac{\partial \pi_{i,j+1}}{\partial \theta_j}$ 和 $\frac{\partial \pi_{i,j+1}}{\partial \theta_{j+1}}$ 的乘积。
    *   其他所有 $D_{jk}$ (当 $|j-k|>1$) 都为0，所以代码中没有 `else` 分支。
    *   这完美地实现了上面 $D_{jk}$ 的数学公式。

```R
# w_mat <- matrix(NA, nrow=n, ncol=J)
# ...
# w_mat[,1] <- -f_mat[,1]
# ... w_mat[,j] <- f_mat[,j-1] - f_mat[,j]
```

*   **`w_mat`**: 这段代码计算了 $\frac{\partial \pi_{ik}}{\partial \eta_i}$。由于 $\pi_{ik} = \mu_{ik} - \mu_{i, k-1}$，根据链式法则，$\frac{\partial \pi_{ik}}{\partial \eta_i} = \frac{\partial \mu_{ik}}{\partial \eta_i} - \frac{\partial \mu_{i,k-1}}{\partial \eta_i}$。这对应于代码中的 `f_mat[,j-1] - f_mat[,j]`（考虑符号后）。

```R
# if (p_cov > 0) {
#   V_i_diag <- rowSums(w_mat^2 / (pi_mat + 1e-8))
#   A_mat <- crossprod(X_covars_only, V_i_diag * X_covars_only)
```
*   **`A_mat`**: 这段代码正在**精确地构建 $I_{\beta\beta}$ (即 $\mathbf{A}$) 矩阵**。
    *   `V_i_diag` 计算了 $\sum_{k=1}^J \frac{(w_{ik})^2}{\pi_{ik}}$，这是上面 $A_{rs}$ 公式中的 $\frac{1}{\sigma_i^2}$。
    *   `crossprod(X, Diagonal(V) %*% X)` 正是 $\sum_{i=1}^n \frac{1}{\sigma_i^2} \mathbf{x}_{i} \mathbf{x}_{i}^T$ 的矩阵形式。

```R
#   B_mat <- matrix(0, nrow=p_cov, ncol=J_minus_1)
#   for(j in 1:J_minus_1){ ... }
```
*   **`B_mat`**: 这段代码正在**精确地构建 $I_{\beta\theta}$ (即 $\mathbf{B}$) 矩阵**。
    *   循环遍历每一个阈值 `j`。
    *   内部的 `term1` 和 `term2` 组合起来，计算了上面 $B_{rj}$ 公式中求和符号 $\sum_{k=1}^J$ 内部的部分。
    *   `colSums(X_covars_only * ...)` 完成了对所有个体 $i$ 的求和 $\sum_{i=1}^n$。

```R
#   V_info <- rbind( cbind(D_mat, t(B_mat)), cbind(B_mat, A_mat) )
#   V_inv <- solve(V_info)
# } else {
#   V_inv <- solve(D_mat)
# }
```
*   **`V_info` 和 `V_inv`**: 这是最后一步，也是画龙点睛之笔。
    *   `rbind` 和 `cbind` **将计算出的 A, B, D 三个分块组装成完整的Fisher信息矩阵 $I$**。
    *   `solve(V_info)` **对完整的信息矩阵求逆**，得到最终的、理论上最精确的方差-协方差矩阵 $\mathbf{V}$。
    *   `else` 分支处理了没有协变量的特殊情况，此时信息矩阵只有 $\mathbf{D}$ 块。

### 总结

您提供的 `NullModel_Fisher版` 是一个通过**极其底层的、手动的、循环和矩阵代数**操作，从第一性原理出发，**一步步构建出理论上最精确的Fisher信息矩阵，然后求逆得到参数方差-协方差矩阵**的函数。

它在理论上是完美的，但在实践中，其大量的循环和复杂的代码结构使其计算效率较低且难以维护。它与 `vcov(clm_obj)` 在功能上是等价的，可以看作是 `vcov` 函数的一个R语言实现。


