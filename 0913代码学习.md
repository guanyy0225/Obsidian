
## Ordinal_plof

`Ordinal_plof` 函数是你整个关联分析流程中一个非常核心的工作单元。它的主要任务是：**针对一个特定的基因（`gene_name`），筛选出其中所有被认为是“可能的功能丧失性”（Predicted Loss-of-Function, pLoF）的变异，然后对这些变异的集合进行 `OrdinalSTAAR` 关联检验。**

让我们把它分解成几个逻辑清晰的步骤来理解。

---

### 函数的目的和输入

*   **目的**: 计算一个基因中pLoF变异集合与你的有序表型（如饮酒频率）的关联p值。
*   **关键输入**:
    *   `gene_name`: 要分析的基因的名字，例如 "ADH1C"。
    *   `genofile`: GDS格式的全基因组数据文件句柄。
    *   `objNull`: 你之前拟合好的零模型对象，包含了残差、协变量信息和样本ID。
    *   `genes_info`: 一个数据框，包含了所有基因的位置信息（染色体、起始、终止位置）。
    *   其他参数：各种阈值（MAF、缺失率等）和设置。

---

### 代码详解：一步步解析

#### 第1步：初始化和全局变异筛选

```R
phenotype.id = objNull$sample_ids
if(is.null(use_SPA)) use_SPA = objNull$use_SPA

filter <- seqGetData(genofile, QC_label)
if(variant_type=="variant") { SNVlist <- filter == "PASS" }
# ... (similar for SNV and Indel) ...
position <- as.numeric(seqGetData(genofile, "position"))
variant.id <- seqGetData(genofile, "variant.id")
```
*   **准备工作**: 从零模型对象中提取出要分析的样本ID列表 (`phenotype.id`)。
*   **全基因组预筛选**: 从GDS文件中读取所有变异的质控标签 (`QC_label`)、位置和ID。它首先创建一个大的逻辑向量 `SNVlist`，标记出全基因组中所有通过基本质控 (`"PASS"`) 的变异。这一步是在内存中完成的，为后续快速筛选做准备。

#### 第2步：定位基因并筛选该基因内的变异

```R
kk <- which(genes_info$hgnc_symbol==gene_name)
gene_info_kk = genes_info[kk, 1:2]
sub_start_loc <- genes_info[kk,3]
sub_end_loc <- genes_info[kk,4]

is.in <- (SNVlist)&(position>=sub_start_loc)&(position<=sub_end_loc)
variant.id.gene <- variant.id[is.in]

seqSetFilter(genofile,variant.id=variant.id.gene,sample.id=phenotype.id)
```
*   **查找基因位置**: 在 `genes_info` 数据框中找到 `gene_name` 对应的行，获取其起始和终止位置。
*   **筛选基因区域**: 使用上一步的 `SNVlist` 和位置信息，从全基因组中筛选出所有位于该基因区域内且通过质控的变异ID。
*   **设置GDS过滤器**: `seqSetFilter` 是一个非常高效的操作。它告诉 `SeqArray` 包：“在接下来的所有操作中，只关注我指定的这些变异 (`variant.id.gene`) 和这些样本 (`phenotype.id`)”。这极大地减少了后续数据读取的IO和内存消耗。

#### 第3步：筛选pLoF功能性变异

```R
GENCODE.EXONIC.Category <- seqGetData(...)
GENCODE.Category <- seqGetData(...)

variant.id.gene <- seqGetData(genofile, "variant.id")
lof.in.plof <- (GENCODE.EXONIC.Category=="stopgain")|...
variant.id.gene <- variant.id.gene[lof.in.plof]
```
*   **读取功能注释**: 在**已经筛选过的基因区域内**，读取GDS文件中存储的`GENCODE`功能注释。
*   **定义pLoF**: 代码定义了哪些注释类别被认为是pLoF，包括：`stopgain`（终止密码子获得）、`stoploss`（终止密码子丢失）、`splicing`（剪接位点变异）等。
*   **最终筛选**: 从基因内的所有变异中，再次筛选出那些功能注释符合pLoF定义的变异，得到最终要分析的变异列表 `variant.id.gene`。

#### 第4步：初步检查和数据提取

```R
if (length(variant.id.gene) < 2) { ... }
# ...
seqSetFilter(genofile,variant.id=variant.id.gene,sample.id=phenotype.id)

# ... (Annotation extraction FOR loop) ...

id.genotype <- seqGetData(genofile,"sample.id")
# ... (Sample ID matching logic) ...
id.genotype.match <- phenotype.id.merge$index

Geno <- seqGetData(genofile, "$dosage")[id.genotype.match,,drop=FALSE]
```
*   **数量检查**: 检查筛选出的pLoF变异数量是否足够（至少2个）。如果太少，就没有进行集合检验的意义，函数直接返回`NA`并跳出。
*   **设置最终过滤器**: 再次调用 `seqSetFilter`，将GDS的焦点缩小到最终的pLoF变异和样本上。
*   **提取功能注释分数**: 如果需要使用注释权重，这里会循环提取`CADD`等功能注释的分数，为后续的`OrdinalSTAAR`做准备。
*   **提取基因型**: `seqGetData(genofile, "$dosage")` 是一个核心操作，它从GDS文件中读取最终确定的变异和样本的基因型矩阵（通常是 dosage 数据，即期望的等位基因拷贝数）。
*   **样本排序**: `id.genotype.match` 确保了提取出的基因型矩阵 `Geno` 的行顺序（样本顺序）与零模型 `objNull` 中的样本顺序**完全一致**。这是保证后续计算正确性的**关键步骤**。

#### 第5步：基因型矩阵的最后处理

```R
getGeno = genoFlipRV(...)
Geno = getGeno$Geno
MAF = getGeno$G_summary$MAF
MAC = getGeno$G_summary$MAC
Anno.Int.PHRED.sub = Anno.Int.PHRED.sub[getGeno$include_index, ]

# ... (Check for NA in annotations) ...
```
*   **调用`genoFlipRV`**: 这是一个非常重要的辅助函数。它接收原始的基因型矩阵 `Geno`，并执行以下操作：
    1.  计算每个变异的MAF（次要等位基因频率）。
    2.  如果某个变异的编码是基于主要等位基因，它会“翻转”（flip）该变异的编码（`0->2, 1->1, 2->0`），确保所有变异都以次要等位基因为准。
    3.  根据`rare_maf_cutoff`等参数，再次筛选出行内符合条件的**稀有变异**。
    4.  对基因型矩阵中的缺失值进行插补（`mean`或`minor`）。
*   **更新数据**: 函数接收`genoFlipRV`处理过的、干净的基因型矩阵`Geno`、对应的`MAF`、`MAC`以及被筛选后的功能注释分数。

#### 第6步：执行核心关联检验

```R
if (is.null(dim(Geno)) | ncol(Geno) == 0) { ... } 
else {
  result.plof = try(OrdinalSTAAR(...), silent = FALSE)
  if (inherits(result.plof, "try-error")) { ... }
}
```
*   **最终检查**: 最后一次检查，确保经过所有筛选后，基因型矩阵`Geno`中仍然有变异。
*   **调用`OrdinalSTAAR`**: 将所有准备好的数据——干净的基因型矩阵`Geno`、MAF、MAC、零模型对象`objNull`和功能注释分数——传递给核心的关联检验函数 `OrdinalSTAAR`。
*   **`try()` 封装**: 使用`try()`来执行`OrdinalSTAAR`。这是一个很好的编程习惯，可以捕捉在统计计算中可能发生的任何意外错误（例如，矩阵奇异等），防止整个分析流程因单个基因的错误而崩溃。如果出错，就返回`NA`。

#### 第7步：收尾和返回结果

```R
seqResetFilter(genofile)
result = c(list("gene_info" = gene_info_kk, "category" = "plof"), result.plof)
return(result)
```
*   **重置过滤器**: `seqResetFilter(genofile)` 清除GDS文件上设置的所有过滤器，使其恢复到可以分析下一个基因的“干净”状态。这是一个**至关重要**的步骤。
*   **格式化输出**: 将基因信息（名字、染色体）、分析的类别（"plof"）和`OrdinalSTAAR`的计算结果（一个包含各种p值的列表）组合成一个最终的列表，并返回。

### 总结

`Ordinal_plof` 函数是一个设计精良、自成体系的分析模块。它像一个流水线一样，输入一个基因名，输出该基因pLoF变异的关联分析结果。其核心在于**高效地从海量全基因组数据中层层筛选出目标变异和样本，准备好所有必需的输入，然后调用核心统计函数进行计算，并稳健地处理可能出现的各种边界情况和错误**。



## OrdinalSTAAR

好的，我们来详细解析 `OrdinalSTAAR` 这个函数。这个函数是整个 `STAAR` 方法的**核心计算引擎**。它的前任（比如 `Ordinal_plof`）负责数据准备，而它的后继（`OrdinalSTAAR_O`）负责具体的p值计算。`OrdinalSTAAR` 的角色就是**承上启下，构建所有检验所需的权重矩阵，并协调调用下游函数**。

---

### 函数的目的和输入

*   **目的**: 接收一个准备好的基因型矩阵 `Geno` 和相关信息，计算并整合多种权重（基于MAF和功能注释），然后调用 `OrdinalSTAAR_O` 来执行所有关联检验（Burden, SKAT, ACAT-V），最终返回一个包含所有结果的综合列表。
*   **关键输入**:
    *   `Geno`: 一个**已经经过初步筛选和处理**的 n x m 基因型矩阵（n个样本, m个变异）。
    *   `MAF`, `MAC`: 每个变异的次要等位基因频率和计数。
    *   `objNull`: 零模型对象。
    *   `annotation_phred`: 一个数据框，包含了每个变异的功能注释得分（如CADD, LINSIGHT等）。

---

### 代码详解：一步步解析

#### 第1步：输入验证和预处理

```R
if (!inherits(Geno, "matrix") && !inherits(Geno, "Matrix")) {
    stop("Genotype is not a matrix!")
}

if(inherits(Geno, "sparseMatrix")){
    Geno = as.matrix(Geno)
}
  
if (ncol(Geno) < rare_num_cutoff) {
    stop(...)
}
  
annotation_phred <- as.data.frame(annotation_phred)
if (nrow(annotation_phred) != 0 & ncol(Geno) != nrow(annotation_phred)) {
    stop("Dimensions don't match for genotype and annotation!")
}
```
*   **健全性检查 (Sanity Checks)**: 这是良好编程实践的体现。代码首先确保输入 `Geno` 是一个矩阵，而不是其他数据类型。
*   **稀疏矩阵处理**: 它检查 `Geno` 是否为稀疏矩阵 (`sparseMatrix`)，如果是，则将其转换为标准的稠密矩阵 (`as.matrix`)。这是因为后续的某些矩阵运算可能不完全兼容稀疏矩阵格式。
*   **变异数量检查**: 确保输入的变异数量不少于设定的阈值 (`rare_num_cutoff`)，否则没有进行集合检验的意义。
*   **维度匹配**: 检查功能注释 `annotation_phred` 的行数是否与基因型矩阵 `Geno` 的列数（即变异数）完全匹配，这是一个非常关键的检查，防止数据错位。

#### 第2步：筛选稀有变异

```R
if (is.null(MAF) | is.null(MAC)) {
    genotype = genoFlip(Geno = Geno)
    # ...
    RV_label = as.vector((MAF < rare_maf_cutoff)&(MAF > 0))
    Geno = genotype$Geno[ ,RV_label]
} else {
    RV_label = as.vector((MAF < rare_maf_cutoff)&(MAF > 0))
    Geno = Geno[ ,RV_label]
}

MAF = MAF[RV_label]
MAC = MAC[RV_label]
Geno = as(Geno, "CsparseMatrix")
annotation_phred <- annotation_phred[RV_label,,drop=FALSE]
```
*   **计算MAF/MAC (如果需要)**: 如果调用时没有提供`MAF`和`MAC`，函数会自己调用 `genoFlip` 来计算它们。
*   **定义稀有变异 (Rare Variants)**: `RV_label` 是一个核心的逻辑向量。它根据 `rare_maf_cutoff` (通常是 0.01 或 0.05) 和 MAF>0 来定义哪些变异是“稀有”的。
*   **最终筛选**: 代码使用 `RV_label` 来筛选 `Geno` 矩阵、`MAF` 向量、`MAC` 向量和 `annotation_phred` 数据框，确保所有后续分析**只包含被定义为稀有的变异**。
*   **转换为稀疏矩阵**: `Geno = as(Geno, "CsparseMatrix")` 这一步很有趣。在前面的步骤中，它将稀疏矩阵转为稠密矩阵以进行某些操作。而在这里，它又将筛选后的 `Geno` 转回**稀疏矩阵**格式。这是因为稀有变异的基因型矩阵通常非常“稀疏”（大部分元素是0），使用稀疏矩阵格式可以极大地节省内存并加速后续的矩阵运算。

#### 第3步：构建STAAR权重矩阵

这是整个函数的**核心逻辑**。

```R
annotation_rank <- 1 - 10^(-annotation_phred/10)

w_1 <- dbeta(MAF, 1, 25)
w_2 <- dbeta(MAF, 1, 1)

w_a_1 <- w_1^2/dbeta(MAF,0.5,0.5)^2
w_a_2 <- w_2^2/dbeta(MAF,0.5,0.5)^2

if(dim(annotation_phred)[2] == 0){
    w_B <- w_S <- as.matrix(cbind(w_1, w_2))
    w_A <- as.matrix(cbind(w_a_1, w_a_2))
} else {
    w_B = as.matrix(cbind(w_1, annotation_rank*w_1, w_2, annotation_rank*w_2))
    w_S = as.matrix(cbind(w_1, sqrt(annotation_rank)*w_1, w_2, sqrt(annotation_rank)*w_2))
    w_A = as.matrix(cbind(w_a_1, annotation_rank*w_a_1, w_a_2, annotation_rank*w_a_2))
}
```
*   **转换功能注释**: `annotation_rank <- 1 - 10^(-annotation_phred/10)` 将PHRED标度的注释分数（如CADD分）转换为0到1之间的“概率”或“秩”标度，使其可以作为权重使用。
*   **MAF权重**: `w_1` 和 `w_2` 是基于MAF的两个核心权重。
    *   `w_1 = dbeta(MAF, 1, 25)`: 这是Beta分布的概率密度。这个权重方案对非常稀有的变异（MAF接近0）赋予非常高的权重，权重会随着MAF的增加而迅速下降。
    *   `w_2 = dbeta(MAF, 1, 1)`: 这是一个在[0,1]区间上的均匀分布，所以这个权重对所有MAf的变异都赋予相同的权重（即无MAF权重）。
*   **构建组合权重**: 代码系统性地构建了用于Burden检验 (`w_B`)、SKAT检验 (`w_S`) 和 ACAT-V (`w_A`) 的权重矩阵。
    *   **如果没有功能注释** (`if` 分支): 权重矩阵只包含两个MAF权重方案。
    *   **如果有功能注释** (`else` 分支): 权重矩阵被扩展。它包含了**纯MAF权重** (`w_1`, `w_2`) 和**MAF权重与功能注释权重的乘积** (`annotation_rank * w_1`, `annotation_rank * w_2`)。`sqrt(annotation_rank)` 用于SKAT，这是由SKAT的数学理论决定的。

#### 第4步：调用下游函数并返回结果

```R
pvalues <- OrdinalSTAAR_O(Geno = Geno, objNull = objNull, ...,
                       weight_A = w_A, weight_B = w_B, weight_S = w_S,
                       ...)
cMAC <- sum(Geno)

return(c(pvalues,
         list(num_variant = sum(RV_label),
              cMAC = cMAC,
              MAF = MAF)))
```
*   **调用`OrdinalSTAAR_O`**: 将所有准备好的数据，包括稀疏基因型矩阵 `Geno` 和刚刚构建的三个大型权重矩阵 `w_A`, `w_S`, `w_B`，传递给 `OrdinalSTAAR_O` 函数。`OrdinalSTAAR_O` 将会使用这些权重来执行所有具体的关联检验。
*   **收集额外信息**: 计算累积次要等位基因计数 `cMAC`。
*   **格式化最终输出**: 将从 `OrdinalSTAAR_O` 返回的p值结果列表，与一些额外的描述性信息（如最终分析的变异数 `num_variant`、`cMAC`、`MAF`列表）合并成一个大的列表，并返回给上游调用者（如 `Ordinal_plof`）。

### 总结

`OrdinalSTAAR` 函数是一个**权重构建器**和**任务协调器**。它不亲自进行p值计算，而是专注于：
1.  **数据清洗**: 确保输入的基因型数据是干净的、符合稀有变异定义的。
2.  **权重生成**: 根据STAAR方法的核心理论，系统性地生成一系列基于MAF和功能注释的权重。
3.  **任务分派**: 将所有准备好的材料打包，分派给下游的“计算工人”`OrdinalSTAAR_O`。
4.  **结果汇总**: 收集计算结果，并附加上下文信息，形成一个完整的分析报告返回。

这个函数的设计体现了良好的模块化编程思想，将数据准备、权重计算和p值计算等不同职责清晰地分离开来。